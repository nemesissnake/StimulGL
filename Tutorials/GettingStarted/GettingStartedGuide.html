<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../../css/Default.css" rel="stylesheet" type="text/css" />
<link href="../../google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
<script src="../../js/jquery.min.js" type="text/javascript"></script>
<script src="../../js/jquery.tableofcontents.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../js/StimulGL.js" type="text/javascript" charset="utf-8"></script>
<script src="../../google-code-prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript" charset="utf-8">
	var StimulGLInfo = new StimulGL_Information();
	var DocTitle = StimulGLInfo.GetDocumentTitle(window.location.pathname);	
	$(document).ready(function()
		{ 
			$("#toc").tableOfContents(
				$("#toc_Area"),        // Scoped to div#toc_Area
				{
					startLevel: 2,    // H2 and up
					depth:      4,    // H2 through H5,
				}
			); 
			prettyPrint();			
		}
	);
	document.write("<title>" + DocTitle + "</title>");	
</script>
</head>
<body>
<script type="text/javascript">StimulGLInfo.GetDocumentHeader(window.location.pathname)</script>
<div id="toc_Area">
<ul id="toc"></ul>
<h2>Introduction</h2>
<p>The purpose of this document is to show you the basic features of StimulGL in a tutorial way. 
The best way working through this document is starting from the beginning and follow all tutorials 
till the end of the document, you could also only follow a single specific tutorial of your interest but then please bear 
in mind that some tutorials expect you to already gained some knowledge of previous tutorials. This Getting started guide is 
not perfect and continuously under construction, so I would be happy to receive feedback about bugs, typos, comments, 
new ideas, etc at sven.gijsen at maastrichtuniversity dot nl.</p>
<h2>Installation</h2>
<p>Installing StimulGL on your computer is easy, you can download the latest installer file from <a href="http://sites.google.com/site/stimulgl/downloads">http://sites.google.com/site/stimulgl/downloads</a>. The public StimulGL source code repository is hosted at <a href="http://github.com/svengijsen/StimulGL">http://github.com/svengijsen/StimulGL</a>. StimulGL strongly depends on the OpenGL 2.0 (or higher) graphics library, so for an optimal usage please make sure that your graphics card supports OpenGL 2.0 (or higher) and that the drivers for this graphics card are up to date. When installing you should make sure to have have administrator privileges. There are some virus scanners which trigger a false virus detection due to the automatic installation of various (network) libraries. If you should receive a detection message like this, which doesn’t apply for the most used virus scanners, you could consider deactivating  the real-time virus detection  while installing StimulGL.  StimulGL is available for Windows in a 32-bit(win32) and a 64-bit(x64) architecture. Please make sure to install the correct architecture for your OS. If you’re not sure which one you need then you can execute the following Command Prompt command (a Command prompt can be opened using the: <em>Windows start button --&gt; Run... --&gt; enter the text 'cmd' --&gt; hit the enter key</em>):</p>
<table class="codeframe"><tr><td><pre class="prettyprint">
echo %PROCESSOR_ARCHITECTURE%</pre></td></tr></table>
<br />
<p>If it echoes with <em>‘x86’</em> then you’re working on a 32-bit architecture, if not then it's an  64-bit architecture.</p>
<p>StimulGL can be easily installed by using the automated installer and clicking through the various installation options, if you're not sure what to choose, you could choose the default options because they apply for a standard installation. </p>
<h3>Installation directory</h3>
<p>The StimulGL installer copies all the needed files in a single directory, by default  this  directory is: <em>C:\Program Files (x86)\StimulGL</em>. Inside this installation directory path you can find the following files and directories:</p>
<h4>Default Files<br />
</h4>
<p><strong>StimulGL.exe</strong> - This is the main StimulGL program executable.<br />
  <strong>StimulGL_NoBindings.bat</strong> - This batch file starts StimulGL with a special option to make sure that no script binding are automatically loaded during startup, 
  see below <a href="#qt-library-script-bindings">Qt Library Script Bindings</a>.<br />
  <strong>logfile.txt</strong> - This logfile saves all StimulGL information, exception, warnings and debugging information, use this file to analyze program execution.<br />
  <strong>uninstall.exe</strong> - Use this file to uninstall StimulGL, you can also use the automatic Windows Uninstall feature or simply delete the whole StimulGL installation directory. <br />
  <strong>assistant.exe</strong> - This executable is used from within StimulGL to show you the help files (inside StimulGL you can open the help files by pressing the <em>'F1'</em> key).<br />
  <strong>*.dll</strong> - Multiple Dynamic link libraries (shared libraries) needed and linked to by StimulGL for various program  features.<br />
  <strong>LICENSE.txt</strong> - This file contains the license agreement information for StimulGL.</p>
<h4>Default Directories<br />
</h4>
<p><strong>apis</strong> - The files inside this directory are used for supporting the StimulGL document editing, like call tips and  auto completion. Each  API (Application Program Interface) defines the way to handle a specific programming language.<br />
  <strong>documents</strong> - This directory contains all the necessary files for the StimulGL Help.<br />
  <strong>examples</strong> - This directory contains many various example and tutorial files  which are also used by this document (see the directory <em>StimulGL\examples\GettingStartedGuide\</em>). These examples  give  the user information about how to use a specific feature or functionality to gain a better understanding of the capabilities. The directory <em>StimulGL\examples\Tutorials\</em> contains various directories with tutorials you can use as a template for your own projects.<br />
  <strong>include</strong> - The default include directory for script files when using the &quot;Include()&quot; script function, see below <a href="#functions-and-includes">Functions and includes</a> chapter.<br />
  <strong>outputs</strong> - This directory is used by the StimulGL plug-ins for the storage of all kind of output, like log-files, generated files, etc. Important! This directory is not yet available after a fresh installation.  StimulGL makes sure to create this directory automatically if it tries to write a file to this directory.<br />
  <strong>plugins</strong> - This is the root directory in which StimulGL searches for plug-ins to load during startup, if compatible then they are automatically embedded in StimulGL and are then ready for usage.<br />
  <strong>plugins/[architecture]/script</strong> - This directory contains the default build Qt script bindings, which make it possible to get access to substantial portions of the Qt API from within Qt Script.<br />
  <strong>qml/plugins/[architecture]/</strong> - This is the root directory in which StimulGL searches for QML plug-ins to include during the startup of the QML viewer.<br />
  <strong>xsd</strong> - This directory contains XML Schema (<em>*.xsd</em>) files, which let StimulGL validate experiment (<em>*.exml</em>) files. It is used to express a set of rules to which an experiment must conform in order to be considered 'valid' according to that schema.</p>
<h2>User Interface</h2>
<p>The StimulGL User interface contains a menu bar, a  area that can contain one or more document editing pane(s) and an output log pane. The menu bar includes the following menu's:</p>
<p><strong>File</strong> -   contains commands for various file operations like opening, saving and printing files.<br />
  <strong>Edit</strong> -  contains commands for the editing of files and search and replace features.<br />
  <strong>Window</strong> -  contains commands for organizing, selecting and viewing one or more document editing pane(s).<br />
  <strong>Markers</strong> - contains commands for the management of markers that can be used to mark or quickly jump to one or more specific position(s) in a loaded document.<br />
  <strong>Document</strong> - contains commands for controlling the execution of various documents like script (<em>*.qs</em>) files.<br />
  <strong>Tools</strong> - contains an option command that lets you configure the StimulGL settings.<br />
  <strong>Plugins</strong> -  contains commands for the loaded/embedded plug-ins in StimulGL. With these commands you can open the plug-in's  User Interface. Plug-ins are automatic divided in <em>Extension</em> and <em>Device</em> plug-ins.<br />
  <strong>Help</strong> -  contains commands for opening the  StimulGL help and viewing release information about  StimulGL and the loaded/embedded plug-in(s).</p>
<h2>Configuration and Settings</h2>
<h3>The StimulGL Registry</h3>
<p>StimulGL makes use of the Windows registry to store its program setting/configuration for the current logged on user. To view this information you can do the following:</p>
<ul>
  <li>Start the Windows Registry Editor by: <em>Windows start button --&gt; Run... --&gt; enter the text 'regedit' --&gt; hit the enter key.</em> You'll notice that a new Registry Editor starts</li>
  <li>Use the Registry Editor to navigate to the <em>HKEY_CURRENT_USER\Software\MBIC, Maastricht Brain Imaging Center\StimulGL(&lt;<strong>version</strong>&gt;, &lt;<strong>architecture</strong>&gt;)</em> path. Inside this path you can navigate through some sub-folders and see all the registry keys used for the StimulGL configuration settings. The settings only apply for the <strong>current logged on user</strong> and only for the StimulGL <strong>version</strong> and <strong>architecture</strong> stated in the corresponding registry path.</li>
</ul>
<h3>Command-line switches</h3>
<p>StimulGL can be started from the command prompt with special defined switches accompanied with one or more parameter(s). By using these command-line switches it is possible to start StimulGL with one or more pre-defined document(s) and/or to enable/disable certain program features.</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the file <em>StartStimulGL.bat</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>. A <a href="http://en.wikipedia.org/wiki/Batch_file"   target="_blank">BAT (*.bat) file</a> is a script file which content  can be directly executed by Windows. </li>
  <li>Examine the batch file content,  the <a href="http://en.wikipedia.org/wiki/List_of_MS-DOS_commands#REM"  target="_blank">REM command</a> is used for commenting the text behind it. There are two commands that are executed, see the file for the explanation about those commands. Also notice that the *.bat extension is not compatible with StimulGL, although you can edit is as plain text. The *.bat extension is not pre-registered inside StimulGL and therefore it's shown in the editor as plain text without coloring, custom styles, fonts, etc...</li>
  <li>Close StimulGL and execute this <em>StartStimulGL.bat</em> file directly from Windows by double clicking it.</li>
  <li>Notice that StimulGL is started and that it automatically opened the file pointed to in the batch file. The command switch '-f' implements this feature, see the below table for all available command switches.</li>
</ul>
<table width="80%" border="1" align="center">
  <tr>
    <th align="center" scope="col">SWITCH</th>
    <th scope="col">PARAMETER</th>
    <th scope="col">DESCRIPTION</th>
  </tr>
  <tr>
    <td align="center">-f</td>
    <td>Path to document(s) separated with a ';' character</td>
    <td>Allows you to let StimulGL automatically open one or more document(s).</td>
  </tr>
  <tr>
    <td align="center">-v</td>
    <td>Verbose mode</td>
    <td>Enables the verbose mode. In this mode StimulGL writes more detailed and more comprehensive information to the log file. It's advised to only use this option for debugging purpose.</td>
  </tr>
  <tr>
    <td align="center">-o</td>
    <td>Option flags (single number)</td>
    <td>Allows you to define one or more option flag(s) for StimulGL. Each flag is defined by a number and multiple flags can be combined together by summing up all their numbers. See the below table for the available flags with their numbers. If you would for example want StimulGL to start with the plug-ins and script bindings disabled you would use the command 'StimulGL -o 3'.</td>
  </tr>
  <tr>
    <td align="center">-e</td>
    <td>Execute active document</td>
    <td>This parameter allows you to let StimulGL automatically execute the active document (after loading the  document(s)). This is the last document defined with the -f switch.</td>
  </tr>
</table>
<p>&nbsp;</p>
<div align="center">
  <table width="80%" border="1">
    <tr>
      <th align="center" scope="col">FLAG</th>
      <th align="center" scope="col">NUMBER</th>
      <th scope="col">DESCRIPTION</th>
      </tr>
    <tr>
      <td align="left">DisableAllScriptBindings</td>
      <td align="center">1</td>
      <td>The Qt Library Script Bindings are not loaded during the startup of StimulGL.</td>
      </tr>
    <tr>
      <td align="left">DisableAllPlugins</td>
      <td align="center">2</td>
      <td>The Plug-ins are not loaded during the startup of StimulGL.</td>
      </tr>
    <tr>
      <td align="left">DisableSplash</td>
      <td align="center">4</td>
      <td>The splash message is not shown during the startup of StimulGL.</td>
      </tr>
    <tr>
      <td align="left">DisableNetworkServer</td>
      <td align="center">8</td>
      <td>The External Network Server (explained later) is not started during the startup of StimulGL.</td>
      </tr>
    <tr>
      <td align="left">VerboseMode</td>
      <td align="center">16</td>
      <td>Verbose mode is enabled during the startup of StimulGL, see also the above table (-v).</td>
      </tr>
    <tr>
      <td align="left">ExecuteDocument</td>
      <td align="center">32</td>
      <td>The document that is active after the StimulGL startup is automatically executed, see also above table (-e).</td>
    </tr>
  </table>
</div>
<p>&nbsp;</p>
<h3>Changing the default User Documents Root Directory
</h3>
<p>StimulGL makes use of a so called default <em>User Documents Root directory</em>, this directory is opened by default whenever you use the <em>File--&gt;Open</em> command to browse for a file. You might want to change this to another directory, you can do this trough the menu <em>Tools--&gt;Option--&gt;Directories</em> command. If you changed this directory you might also want to copy the already present examples from the original folder to this directory.</p>
<h2>Editing and Scripting</h2>
<p>At first glance StimulGL features  various text editing tools that are found in standard text editing applications, like for example notepad. StimulGL  allows to  open and edit multiple documents  simultaneously, the look and feel for these opened document(s) depends on the document type (that is defined by the document extension). StimulGL  automatically detects certain (pre-registered) document types (by extension), this is further explained in the example <a href="#running-an-experiment-file-directly-from-stimulgl">Running an Experiment File directly from StimulGL</a>. When such a  specific document    type is  detected and opened by StimulGL then the internal document editor is automatically configured  for this document type. This internal document editor configuration contains features like styling choices, support for syntax styling, code completion and call tips that can support  the editing and thus makes it more  more user-friendly.<br />
  A important  file type for StimulGL is  that of a script (<em>*.qs</em>) file. This file may contain <a href="http://en.wikipedia.org/wiki/QtScript" target="_blank">QtScript</a> code and can be executed by the StimulGL internal Script Engine. This makes StimulGL be more that just a rich multiple document editor, namely also a script interpreter. This is handled by the internal script engine that can execute script code. The supported QtScript scripting language is based on the <a href="http://en.wikipedia.org/wiki/ECMAScript" target="_blank">ECMAScript</a> standard with a few extensions, such as <a href="http://qt-project.org/doc/qt-5.1/qtcore/signalsandslots.html" target="_blank">QObject-style signal and slot connections</a> (which is explained later in this guide).</p>
<h3>Exercises - Editing</h3>
<h4>The StimulGL User Interface</h4>
<ul>
  <li>Start StimulGL by double clicking the StimulGL executable (StimulGL.exe). </li>
  <li>Notice the splash screen that  appears during the startup  of StimulGL (the time this splash screen is visible may depend on fast your system is). During this splash screen various tasks like plug-in detection/loading and the creation of the User Interface are performed.</li>
  <li>During the execution of StimulGL all kind of logging information is written to the standard log file (&lt;StimulGL directory&gt;/logfile.txt).</li>
  <li>Open the above standard log file with StimulGL, with the menu command File--&gt;Open... and then browsing and selecting the file.</li>
  <li>Notice that StimulGL opens the log  file and shows it textual content in a new document editing pane. The log file already contains some gathered information of the first StimulGL startup like the OpenGL version your system supports. Version 2.0 or higher is advised for an optimal usage. Each entry in the log file contains a date/time stamp and this  information is never  erased by StimulGL, each new entry is automatically appended to this file. If the file size gets too big (&gt;200MB) after a while you could consider to  delete it if you don't need the information inside anymore.</li>
  <li>We can see that StimulGL automatically adds a line number in front of the text lines. In the right lower corner we can also see the total number of lines and some information about the cursor position inside the document.</li>
  <li>It's possible to open and edit multiple files simultaneously, let's try this by opening another file, open the file (&lt;StimulGL directory&gt;StimulGL_32\examples\scripts\AnalogClock.qs) by using the shortcut key combination CTRL+'o' and then browsing and selecting the file.</li>
  <li>This file has the extension (*.qs) and is known and detected  as a StimulGL script file. Although the document contains no text styling formatting information (only textual), the document is shown in the new document with a special styling formatting. This is automatically done by the internal document editor because it already knows how to handle this type of file. </li>
  <li>If we open the <em>Window</em> menu we can see the two opened documents, you can switch between them pressing the CTRL + TAB shortcut key combination or maybe by selecting one from the <em>Window</em> menu. Furthermore if you choose the <em>Tile</em> option the two documents are automatically tiled, alternatively you can move and resize them.</li>
  <li>Recently opened documents (the last 8 previously opened document(s)) can be quickly reopened using the <em>File</em> menu and then selecting the appropriate document, try this after having closed the opened documents.</li>
  <li>Standard <em>Find</em> and <em>Replace</em> options  are  available from the <em>Edit</em> menu. Maybe you want to try these options to find out how they work.</li>
  <li>The <em>Markers</em> menu contains several commands for accessing  the markers features used for quick navigation inside a document. After you have opened a document you can click with your mouse on a line number of a document to create or remove a marker or alternatively use the <em>Add/Remove marker</em> command from the <em>Markers</em> menu. Make the cursor jump to a specific marker by using the <em>next/previous marker</em> commands. Try the <em>Markers</em> menu commands to find out about how to use the quick navigation marker features. </li>
  <li>The <em>Document</em> menu contains commands for handling the execution of documents by an internal  engine, this is explained later.</li>
  <li>The <em>Tools</em> menu contains commands for the configuration of StimulGL.</li>
  <li>The <em>Help</em> menu contains commands for accessing all kind of versioning information about StimulGL and it's loaded plug-ins. Another important feature is the <em>Help Contents</em> command (or use the F1 key) that opens a viewer for the StimulGL Help collection. This Help collection contains extensive information about StimulGL, the available plug-ins, a complete script reference and off course this Getting started guide.</li>
  <li>Another UI component is the <em>Output Log</em> pane  on default in the lower part (you can move and resize this pane) of the StimulGL window. We'll see that this  <em>Output Log</em> pane is very useful for testing and debugging scripts. Some commands for for this pane are available if you right-click with your mouse onto it or by opening the <em>Edit</em> --&gt; <em>Output Log Pane</em> menu.</li>
</ul>
<h3>Exercises - Scripting</h3>
<p>Although the below scripting exercises a pretty easy to understand for a general programmer, they do expect you to have already gained some knowledge about scripting and basic programming. </p>
<h4>Hello World script</h4>
<p>Let's first try to open/view and execute a very basic script with StimulGL</p>
<ul>
  <li>Start StimulGL</li>
  <li>Open the file (<em>File -&gt; Open</em>... or use the <em>Ctrl+’o’</em> key combination) <em>HelloWorld.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>You can see again that the plain text is automatically highlighted/styled according to the syntax it contains. Text/code can be commented using the single line comment <em>‘//’</em> or the multi-line <em>‘/*’</em> and <em>‘*/’</em> combination, commented text is not executed by the internal script engine but can be  used for the documentation of script code for a better understanding. In the script three variables are declared (using the <em>var</em> statement) and a value is assigned to them,  the third variable  is assigned to the calculated sum  of the first two variables. The value of this third variable is then used in a special function called <em>Log()</em> that  appends the provided string parameter to the StimulGL Output Log pane. To clear the Output Log pane right-click on it and select <em>Clear All Output Item(s)</em>. Some times you might want to copy some text  from the output log pane, you can do this by selecting the text to copy  to the clipboard and then right-click on it and select <em>Copy Selected Text</em>. Alternatively you can also use the default operating systems Copy/Paste commands.</p>
<ul>
  <li>Execute the QtScript code (done by the internal StimulGL script engine) by using the <em> ‘F5’</em> key or by the menu  <em>Document -&gt; Execute</em> command.</li>
</ul>
<p>The QtScript code of the current active document is then evaluated and executed. You can see  in the Output Log pane when the script started/stopped evaluation and how many time it took to evaluate. We can also see that for each <em>Log()</em> function call there’s one  additional line appended to the Log Output pane.</p>
<h4>Functions and includes</h4>
<p>Within the StimulGL script (QtScript) you can define functions and includes that allow you to structure this script in a more modular way that give you the advantages  of <a href="http://en.wikipedia.org/wiki/Code_reuse" target="_blank">re-usable code</a>. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the <em>FunctionsAndIncludes1.qs</em> and the <em>FunctionsAndIncludes2.qs</em> files found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>View/activate the <em>FunctionsAndIncludes1.qs</em> file you can use the Window menu for this purpose or use the<em> Ctrl+TAB</em> key combination to navigate through the opened documents.</li>
</ul>
<p>Notice that the script starts with an <em>Include</em> statement that allows you to include/embed other script (*.qs) files and thus also their code functionality. The <em>string</em> parameter from the <em>Include</em> statement holds the script file to include.<br />
  The provided string can be a absolute or a relative path, if only a filename is defined than the <em>Include</em> function searches for the filename inside the directory where the current active running script document is stored.  If the file is not found here then it  searches for the file in the default include directory (see <a href="#default-directories">Default Directories</a> chapter), if the file is even then not found then the search is extended to the optionally directories that are defined by the <em>Tools-&gt;Options-&gt;Scripting-&gt;Include Directories</em> setting.<br />
   In this case a function named <em>testFunction3</em> is defined in the included script file. 
  You can see that a function header doesn’t need to specify the amount and type of parameter(s) it accepts, nor does it need to specify the return value (see <em>testFunction3</em>). The function <em>testFunction1</em> shows how you can iterate through the parameters it receives, but maybe you want to specify the parameters explicit like <em>testFunction2</em> to make a better coding overview for a better code <a href="http://en.wikipedia.org/wiki/Readability" target="_blank">readability</a>. <br />
  Before the script ends we should set the defined functions again to null to make sure that the script engine can perform a successful <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank">garbage collection</a>, this is explained later (see <a href="#dynamic-object-construction-and-garbage-collection">Dynamic Object construction and Garbage Collection</a>).</p>
<ul>
  <li>Execute the QtScript code.</li>
</ul>
<h4>Additional StimulGL Functions</h4>
<p>In a previous exercise we already made use of the additional <em>Log()</em> function to write text to the log output pane which can be very useful for debugging purpose. This  <em>Log()</em> function is made available in the script environment by the StimulGL application to provide a convenient way for the user to easily output  information from the running script to the main StimulGL User Interface. There are more additional convenient functions made available to the script environment by the StimulGL application, as you can see in the following example. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the file <em>AdditionalStimulGLFunctions.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Execute the QtScript code.</li>
  <li>Take a look at the script and make sure that it makes sense to you.</li>
</ul>
<p>When we look at the script code we see that it uses some additional functions prepended with the “<em>StimulGL</em>” namespace (followed/separated by a dot) because these used functions belong to the StimulGL main program. We see some functions that can retrieve absolute directory paths, environment information etc, but also some functions that perform StimulGL UI functionality like <em>find()</em> and<em> closeSelectedScriptFile()</em>. All available additional StimulGL script functions are described in the  <a href="../../References/Script/StimulGLMainApp/Doxygen/class_main_window.html">StimulGL Main Application Scripting Reference</a>. <br />
The <em>Log()</em> function is actually the same as the  <em>StimulGL.write2OutputWindow()</em> function (internally it does exactly the same) but because this functionality it's so commonly used and the <em>StimulGL.write2OutputWindow()</em> function takes a lot of characters(key presses)and time to code that it has been made available to the script engine under the short <em>Log()</em> function signature.</p>
<h4>Dynamic Object construction and Garbage Collection</h4>
<p>The internal StimulGL script engine uses a <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank">garbage collection</a> method to reclaim memory used by the script objects when they are no longer needed. An object's memory can be automatically reclaimed when it is no longer referenced anywhere in the scripting environment context by the script engine garbage collector. If all referenced (allocated) memory is successfully reclaimed and the script context ends then the internal StimulGL script engine automatically exits. If this is not the case then the script remains in a running state and thus does not end. For the garbage collection to work properly  you need to make sure that you follow the following guidelines before ending the script context:</p>
<ol>
  <li>Disconnect all signal/slot connections, signal slot connections are explained later in chapter (see the <a href="#the-signalslots-mechanism">The Signal/Slots mechanism</a> chapter).</li>
  <li>Set all dynamic constructed object (where you used the new statement) to null.</li>
  <li>Set all defined script functions to null.</li>
  <li>At last optionally call the <em>StimulGL.cleanupScript()</em> function to force a remaining automatic garbage collection to make sure that all the claimed script memory is released.</li>
</ol>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the <em>ObjectConstructionAndGarbageCollection.qs</em> file found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Execute the QtScript code.</li>
</ul>
<p>If you look at the script code then you can see that a local (built-in type) <em>String</em> object is constructed  using the <em>new</em> keyword (which claims/allocates memory). This object is constructed from a <em>String</em> object class and its member functions can now be used to change the newly created <em>String</em> object. Before we end the script context we call the script function (<em>ScriptCleanupFunction()</em>) that makes sure that the above guidelines for a successful garbage collection are followed.</p>
<p>We can test what happens if we don't do follow these guidelines:</p>
<ul>
  <li>Comment (using the '//' comment tag in front of the line) the line <em>replaceFirstCharacter=null;</em> (which takes care of setting the script function to null).</li>
  <li>Execute the QtScript code.</li>
  <li>Notice that the 'Execute' command in the 'Document' menu (or the corresponding toolbar button) is now disabled. This button is automatically disabled by the internal script engine when the script is running. Because the <em>replaceFirstCharacter</em> function is not set to null the script engine doesn't know/detect that all referenced(allocated) memory is successfully reclaimed and that it can safely exit the running script. The 'Execute' commend now remains disabled. </li>
  <li>We can force the script engine to restart/release the current script that is running by using the menu <em>Document-&gt;Restart Script Engine</em> command, press the &quot;Restart Script Engine button&quot; now.</li>
  <li>Uncomment (by removing the '//' comment tag) of the line with the command <em>//StimulGL.cleanupScript();</em> Now execute the script again and notice that this time the script does return to it's pending stage because by enabling this line of code the script engine tries perform the the garbage collection automatically.</li>
</ul>
<h4>Qt Library Script Bindings</h4>
<p>To further extend the script engine functionality StimulGL has a feature that automatically detects and integrates (pre-generated) Qt bindings for the Qt Script  environment. With these  bindings you get access to substantial portions of the Qt API from within Qt Script. These script binding are automatically loaded from the shared libraries inside the <em>StimulGL/plugins/[architecture]/script/ directory</em> during startup. 
These shared libraries include script binding for the Qt libraries: 
QtCore, 
QtGui, 
QtNetwork, QtWebkit,
QtXml, 
QtXmlPatterns, 
QtSvg, 
QtSql, 
QtOpenGl and 
QtUiTools, see also the <a href="http://qt-project.org/doc/qt-5.0/qtdoc/modules.html" target="_blank">Qt Project Documentation</a>.
</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the shared library named <em>qtscript_gui.dll</em> exists in the directory <em>StimulGL\plugins\[architecture]\script\</em>.</li>
  <li>Open the file <em>QtLibraryScriptBindings.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>This example makes use of the <a href="http://qt-project.org/doc/qt-5.1/qtgui/qcolor.html" target="_blank">QColor</a> and the <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qcolordialog.html" target="_blank">QColorDialog</a> class from the QtGui library which is made available in the scripting environment due to the automatic linkage to the Qt Bindings (<em>qtscript_gui.dll</em>), as explained above. <br />
  The script first constructs a <em>QColor</em> object. The passed parameter in the <em>QColor</em> constructor is used to preset the color. A static member function (<a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qcolordialog.html#getColor" target="_blank">getColor()</a>) of the <em>QColorDialog</em> class  is used to present to the user a color picking dialog allowing a selection of a custom color that is then copied to the <em>QColor</em> object.
  This color picking dialog  prevents further script execution and gives the control back after the user accepted or rejected the color picking dialog. </p>
<ul>
  <li>Examine and execute the QtScript code.</li>
</ul>
<p>Notice how the output log pane notes that the script is fully Evaluated after the script engine actually ends (after the <em>ScriptCleanupFunction()</em>). We’ll see in the next chapter that this doesn’t have to be like this.</p>
<h4>The Signal/Slots mechanism</h4>
<p>The StimulGL script engine  supports  <a href="http://qt-project.org/doc/qt-5.1/qtcore/signalsandslots.html" target="_blank">Qt-style signal and slot connections</a>, that can make the script very flexible. It allows the script to dynamically connect/disconnect various objects to each other by  connecting their member signals and slots. Slots can be custom script functions or member functions from script objects. It is currently not possible to define a new signal in the script, this means that all signals must be defined in their underlying C++ object classes. The following example shows how Signal/slots connection can be used inside the script to pass a signal (an event)  from one object to another slot (a script function).</p>
<ul>
  <li>Start StimulGL.</li>
</ul>
<p>Make sure that the shared library named <em>qtscript_gui.dll</em> exists in directory <em>StimulGL\plugins\[architecture]\script\</em>.</p>
<ul>
  <li>Open the file SignalSlotMechanism.qs found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>This example is almost the same as the previous example, it only differs in the way the color picking dialog is created and handled. This example makes use of the <em>QColor</em> and the <em>QColorDialog</em> class from the <em>QtGui</em> library which is made available in the scripting environment due to the automatic linkage to the <em>Qt Bindings</em> (<em>qtscript_gui.dll</em>) as we saw before. <br />
  The script starts with constructing two objects, a <em>QColor</em> and a <em>QColorDialog</em> object. In this example the color picking dialog is shown using the constructed object from the class <em>QColorDialog</em> with the use of an non-static member function (see <em>dialog.open();</em>). The script now need to know when the user picked a color or closed the dialog, this is achieved by a signal/slot connection (<em>see dialog.finished.connect(this, dialogFinished);</em>) which makes sure that a script function (<em>dialogFinished(result)</em>) gets called whenever the the color picking dialog finishes (and fires the <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qdialog.html#finished" target="_blank"><em>finished()</em></a> signal). When our script function  (<em>dialogFinished(result)</em>) gets called we  make sure that  the we perform a successful script cleanup and exit. </p>
<ul>
  <li>Examine and execute the QtScript code.</li>
</ul>
<p>Notice how the output log pane notes that the script is fully Evaluated before the script engine actually ends (after the <em>ScriptCleanupFunction()</em>). </p>
<h4>StimulGL Plug-in Script Bindings</h4>
<p>StimulGL has the ability to automatically integrate (load and embed) plug-ins that extend the functionality  of StimulGL (see the <a href="../../References/Plugins/PluginReference.html">plug-in reference</a> for a list of available plug-ins). These plug-ins can  expose their functionality to the StimulGL Script engine, allowing the user to take advantage of these plug-ins  inside the script context. Usually this is done by constructing a object dynamically inside the script from the exposed plug-in script class which we can then make use of. Each plug-in has the possibility to implement its own custom  User Interface that can be opened from StimulGL, normally this User Interface offers a user friendly way  for  accessing and testing the plug-ins functionality. For a c++ programmer it's not difficult to create a new custom StimulGL plug-in to extend the program (if you are interested in this please contact us at sven dot gijsen at maastrichtuniversity dot nl).</p>
<p><u>Important</u>: The internal plug-in object, used by the plug-ins User Interface to show its functionality, is in no way connected to the script or any script object created from this plug-ins class! This is because that internal plug-in is only used for testing purpose and easy access it's features but not for a global configuration. Objects that are dynamically created inside the script context from the plug-ins script class are new instances and in no way connected to the plug-ins UI.</p>
<p> StimulGL has totally no knowledge of the internal plug-ins implementation and does not define  what or how they should do things, making this plug-in framework  very flexible for developers. A StimulGL installation contains some standard plug-ins that are automatically installed together with StimulGL. These can be installed as a separate plug-in file or build inside the StimulGL executable (these plug-ins are called <em>static</em>).  Plug-ins are grouped in either <em>Device</em> or <em>Extension</em> plug-ins. As we already know by now a plug-in can define a custom (script) class from which we can construct new script plug-in objects. Let's first take a look at a plug-ins implemented UI and some of its features:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the<em> </em>StimulGL plug-in named <em>KeyBoardPlugin</em> is available by opening the menu <em>Help -&gt; About StimulGL</em> command. Inside the plug-ins listbox you should see this plug-in listed. It's marked as  <em>Static</em> which means that this plug-in is build into the StimulGL executable and therefore is always available for usage. <em>Dynamic</em> plug-ins are automatically loaded  and embedded  at the startup of StimulGL.  </li>
  <li>Open the <em>KeyBoardPlugin</em> User Interface by opening the menu <em>Plugins -&gt; Device Plugins -&gt; KeyBoardDevice Plugin</em>.</li>
  <li>This plug-in is capable of capturing key presses/releases, you can try this by clicking on the <em>Start Capture Thread</em> button and press some keys. Play around with the plug-ins dialog features to get an understanding of what the plug-in can do.</li>
  <li>Click on the <em>Stop  Capture Thread</em> button and Close the plug-ins UI dialog.</li>
</ul>
<p>We can also construct a new plug-in object from this plug-ins script class, lets try this:</p>
<ul>
  <li>Open the file <em>StimulGLPluginScriptBindings.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Examine the script quickly and then execute the QtScript code.</li>
  <li>Repeat pressing a keyboard key (i.e. key <em>'4') </em> until the script finishes.</li>
</ul>
<p>We saw that the key codes (a unique number for each key) of the captured key presses where logged to the Output Log Pane and after having pressed 4 times the script automatically ended. The line <em>var KeyBoardCaptureObj = new KeyBoardCapture(); </em>constructs a new  object from the class defined by the KeyBoardCapture plug-in. This object is then used by the script. We now need to know what this plug-in object can do:</p>
<ul>
  <li>Open the <em>Help Contents</em> by pressing the <em>'F1'</em> key.</li>
  <li>Enter '<em>KeyBoardCapture</em>' in the help search field and press enter. A help document with the name <em>KeyBoard Device script class</em> is found let's open that by clicking on the link. </li>
</ul>
<p>This help document is a script class reference, that shows all the available signals/slots and member function that can be used inside the script context for this plug-ins script class.  </p>
<h2>Creating Experiments with the Experiment Manager</h2>
<p>We saw that StimulGL is a rich multiple document editor with an internal script engine that can execute scripts and that it can be extended by the use of custom  plug-ins. However, the  main goal during  development  was to create a platform for editing and executing behavioural experiments for supporting cognitive research. Creating behavioural experiments can be done by using solely the StimulGL script engine but this is pretty difficult for an average user. Therefore a StimulGL plug-in called the <em>Experiment Manager</em> was created to support  more functionality for creating and managing behavioural experiments, see the <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html">Experiment Manager documentation</a>. In this chapter we’ll take a look at it’s features and how it can be used to create/edit and run custom experiments.</p>
<h3>Running an Experiment File from the Experiment Manager Plug-in User Interface</h3>
<p>The Experiment Manager User Interface is available through the <em>Plugins -&gt; Extensions Plugins</em> menu. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the (static) StimulGL plug-in named <em>ExperimentManagerPlugin</em> exists  by opening the menu <em>Help -&gt; About StimulGL</em> command. </li>
  <li>Open the <em>Experiment Manager </em>plug-ins User Interface by opening the menu <em>Plugins -&gt; Extensions Plugins -&gt; Experiment Manager Plugin</em> command. </li>
  <li>Click the<em> Run Experiment File</em> button to browse, open and execute the <em>PolarAngle.exml</em> Experiment file found in the <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\RetinotopicMapping\</em>directory.</li>
</ul>
<p>We should now see a default screen that allows us to start the experiment (by pressing the<em> ‘ALT’ key</em>) or abort (by pressing the <em>CTRL + ‘a’ key</em> combination). After we have started the experiment we should see a <em>Polar Angle Retinotopic experiment</em> running. We can always abort an experiment by pressing the <em>CTRL + ‘a’</em> key combination or wait until the experiment is finished.</p>
<ul>
  <li>Abort (<em>CTRL + ‘a’</em>) the experiment or wait until it has finished and close the <em>Experiment Manager</em> plug-ins User Interface.</li>
  </ul>
<p>The experiment we just executed by the Experiment Manager is completely defined in a Experiment File (*.exml), this is explained later. For now we only need to know that we can run these experiment files from the Experiment Managers plug-ins UI.</p>
<h3>Running an Experiment File directly from StimulGL</h3>
<p>Plug-ins like the <em>ExperimentManager</em> plug-in can pre-register specific file types (by extension) in StimulGL (as we mentioned in the beginning of this getting started guide). These registered file types can then be automatically forwarded to the plug-in when loaded and/or executed in StimulGL (without StimulGL interfering). This custom file handling can then be for example a custom widget that contains a rich User Interface that can edit a specific file when it is opened in StimulGL. It could also be an custom file handler that activates when a specific file type gets executed (by using the menu <em>document--&gt;Execute</em> command) in StimulGL. The later custom file (*.exml) execution handler is also implemented by the  <em>Experiment Manager</em> plug-in. <br />
  The Experiment Manager plug-in automatically registers the (<em>*.exml</em>) file type extension in StimulGL and implements a custom execution handler for this type of file. This execution handler is called whenever you use the menu <em>Document--&gt;Execute</em> command in StimulGL. Due to this it’s possible to directly start an experiment file after opening this document with StimulGL even without using the  plug-ins User Interface like we saw above. Let's try this:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open again the file <em>PolarAngle.exml</em> Experiment file found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\RetinotopicMapping\</em> with StimulGL directly.</li>
  <li>Execute the Experiment file directly by using the key <em>‘F5’</em> or through the <em>Document -&gt; Execute</em> command.</li>
  <li>Press the <em>'TAB'</em> key to start the experiment.</li>
  <li>Abort (<em>CTRL + ‘a’</em>) the experiment or wait until it has finished completely.</li>
</ul>
<p>We now saw that we can start the same Experiment file directly from within StimulGL by using the execution handler for this file type implemented by the <em>Experiment Manager</em>.</p>
<h3>The Experiment File (*.exml)</h3>
<p>The <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#exml-file-definition">Experiment File (<em>*.exml</em>)</a> is an sort of <a href="http://en.wikipedia.org/wiki/XML" target="_blank">XML file type</a> that describes an experiment. The Experiment file consist out of different sections that determine the behavior/configuration of the experiment, these sections are automatically processed by the Experiment Manager (a short name for the Experiment Manager used in this document is <em>EM</em>). The below global explanation about these sections may be difficult to understand for an average user (non-programmer), this should not be a problem for the usage, but this explanation together with further examples should make things a little bit more clear. In the future development of StimulGL the EM plug-in will be extended with a user friendly interface to edit these sections.</p>
<p>If we take a look at the example Experiment file we can see that after a standard header that there are different elements defined starting with a start-tag ( for example: &lt;section&gt;) and ending with a end-tag (for example: &lt;/section&gt;) or empty-element tags (for example: &lt;param1/&gt;). These elements may also include other element, named child-elements. The child-elements from the &lt;EXML&gt; element have a special meaning, these are:</p>
<p><strong>&lt;defines&gt;</strong> : Within this section we  define  global Experiment settings.<br />
  <strong>&lt;declarations&gt;</strong> : This section declares objects that are automatically constructed and can then be  used in the experiment. These  can be standard Qt objects (available via the script bindings) or objects derived from plug-ins script classes. These objects are then automatically constructed at the initialization of a experiment (and afterwards automatically destructed). They are managed by the EM.<br />
  <strong>&lt;connections&gt;</strong> : The above derived objects have no or less  functionality on their own within the Experiment execution if they don't cooperate with other objects. We use this section  to connect them to other declared objects using the <a href="http://qt-project.org/doc/qt-5.0/qtcore/signalsandslots.html" target="_blank">Qt-style signal and slot connections</a>. We can also connect them to the EM itself. These connected objects are also automatically disconnected before the experiment has been stopped, we don't have to take care of this.<br />
  <strong>&lt;initializations&gt;</strong> : Often we first need  to  initialize a constructed  objects before we can  actually use them in the  running Experiment, maybe we first need to perform some configuration? This section allows us  to do this.<br />
  <strong>&lt;actions&gt;</strong> : This section contains the actual actions that should be performed when running the Experiment. Inside the <strong>&lt;blocks&gt;</strong> child-element you can  describe an sequentially Block-design experiment with pre-defined <strong>&lt;parameters&gt;</strong> that are used by an derived object during the execution of the experiment.<br />
  <strong>&lt;finalizations&gt;</strong> : This section allows you to perform some operations before the EM finalizes the experiment.</p>
<h4>The Experiment Structure and the Experiment Triggering</h4>
<p>Before the Block-design experiment actually starts the user is presented a screen where the experiment can be started or aborted as we have seen before. After the user  pressed the <em>'TAB'</em> key to start the experiment, the EM executes the experiment defined in the (&lt;actions&gt;, &lt;blocks&gt;) sections (or the CTRL+a key combination to abort the Experiment).<br />
  Inside the <em>&lt;blocks&gt;</em> section of the <em>&lt;actions&gt;</em> section you can find the sections that define the Experiment Structure  Block(s)/Trial(s)/Internal  and External Trigger(s). This Experiment Structure is used while running the Experiment to step through the different BlockTrial(s) that can be defined with parameter(s) <em>&lt;parameter&gt;</em> for the corresponding object(s) <em>&lt;object&gt;</em>. The Experiment Structure is optimized for the definition of an Block Experiment design. In a block design, two or more conditions are alternated in blocks and trials, these conditions can be defined  by the different parameters for the objects. Each BlockTrial will have a duration of a certain number of i.e. fMRI scans and within each block only one condition is presented. By making the conditions differ in only the cognitive process of interest, the fMRI signal that differentiates the conditions should represent this cognitive process of interest.<br />
  We see that there are only 2 Blocks defined in the above  <em>PolarAngle.exml</em> Experiment file. The first Block that is executed is the one with Block number <strong>0</strong> (<em>see &lt;block_number&gt;0&lt;/block_number&gt;</em>) and  named <strong>Fixation_Block</strong> (<em>see &lt;name&gt;Fixation_Block&lt;/name&gt;</em>)  has an internal Block-ID of <strong>0 </strong>(<em>see &lt;block ID=&quot;0&quot;&gt;</em>). This Block  only takes <strong>1</strong> Trial (the number of repetitions of this Block) <strong></strong>(<em>see &lt;nr_of_trials&gt;1&lt;/nr_of_trials&gt;</em>) and one Trial takes <strong>2</strong> Internal Triggers <strong></strong>(<em>see &lt;nr_of_internal_triggers&gt;2&lt;/nr_of_internal_triggers</em>) and one Internal Trigger takes <strong>1</strong> External Trigger (<em>see &lt;nr_of_external_triggers&gt;1&lt;/nr_of_external_triggers</em>). So what does this exactly mean? If the Experiment Structure is externally triggered by an signal that for example fires each time the fMRI scanner scans one volume (i.e. Tr = 2 Seconds) than the external trigger counter will increment each 2 seconds because the Experiment Manager will then automatically step through the Experiment Structure defined here. Because one Internal Trigger only takes 1 External Trigger in this Block the Internal Trigger is also incremented each 2 seconds (if <em>nr_of_external_triggers</em> would be set to 3 then each Internal Trigger would take 6 (=3*2 seconds in this example) seconds. After 2 Internal Triggers the Trial counter would be incremented if there were more than one Trials defined but because the is not the case it will then advance to the  next Block with  Block Number 1 (=0+1=1), because the Blocks are sequentially activated by their defined Block Number (starting with 0). We now know that the Block with Block Number 0 (the 'Fixation_Block') only takes in total 2 External Triggers, thus 4 Seconds in our example.<br /> 
  The Block with Block Number <strong>1</strong> would thus take (1 External Trigger * 36 Internal Triggers * 6 Trials * 2 seconds per External Trigger) 432 seconds, each Trial  takes 72 seconds. We also see different Parameters defined in the Block definitions. These parameters are linked to the Object with Object ID <strong>1</strong> (<em>see &lt;object ID=&quot;1&quot;&gt;</em>)<em>, </em>this is the Object with the name <strong>RetinoMap_Object_1</strong> derived from the script class <strong>RetinotopyMapper</strong> (see the ObjectID=1 definition in the <em>&lt;declaration&gt;</em> section). The available Parameters from the <strong>RetinotopyMapper</strong> class are described in a <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#retinotopic-mapping">detailed explanation here</a>. We see that the parameters have an fixed value within each Block. Parameters that aren't defined automatically use their default value and if they are changed inside the Experiment File they hold/buffer that value until the Experiment ends. Whenever the current Experiment Structure switches to a new  BlockTrial (Block or Trial) the defined parameter values are parsed and used in the experiment. By implementing a Experiment like the above we have an declarative way of defining different conditions with parameters in a block design Experiment that is defined by our Experiment Structure. The parameter values are now statically defined (they have fixed values) in the Experiment File, later on we'll see how we can dynamically change them inside our  script environment. When there are no more Block to run the Experiment is automatically finalized (see the <em><strong>&lt;</strong>finalizations<strong>&gt;</strong></em> section) and hereafter stopped. We can also always manually abort the Experiment when its running by pressing the CTRL+a (for <strong>A</strong>bort) key combination. </p>
<p><strong><em>Important:</em></strong><br />
  Sometimes we also want to be able to increment the External Trigger (see above) manually for testing purpose, we can do this with   the available key combination CTRL+T (for <strong>T</strong>rigger), for each of this key combination press the External Trigger counter increments one step.</p>
<p>In the above example we imagined that the Experiment would be Triggered externally by a signal that would be synchronized with a fMRI scanner Trigger. But in real this Experiment is triggered automatically by a object derived from a <em>TriggerTimer</em> class each 1000 milliseconds, next we'll see how this is done.</p>
<h4>Connecting Experiment Objects</h4>
<p>The declared objects in the <em>&lt;declarations&gt;</em> section of the Experiment file have an unique &lt;object ID=&quot;&quot;&gt; tag that is used in all of the remaining  sections to address to that object. In the experiment file, in the declarations section, we see that an object named <em>Timer_Object_1</em>, with ID number 0, is declared and derived from the <em><a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_trigger_timer.html">TriggerTimer</a></em> script class (this class is made available by the EM). This TriggerTimer object is then used in the Experiment for the automatic triggering of the experiment by connecting its <em>timeout()</em> signal for triggering the experiment. We can see this in the <em>&lt;connections&gt;</em> section, the TriggerTimer <em>timeout()</em> signal is here connected to a <a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_g_l_widget_wrapper.html">incrementExternalTrigger()</a> slot of the <em>RetinotopyMapper</em> class derived object. We use this <em>TriggerTimer</em> class derived object because it can perform very accurate timing and triggering (by emitting a signal) other objects. <br />
We then also initialize (&lt;initializations&gt;) the <em>TriggerTimer</em> object with the<em> startTimer(1000) </em>function before the Experiment actually starts. This function initializes and starts the <em>TriggerTimer</em> object which then signals/emits the<em> timeout()</em> signal each 1000 milliseconds. When the Experiment stops or has been aborted the <em>Timer_Object_1</em> is stopped automatically automatically because of the slot <em>stopTimer()</em> is then called (see the <em>&lt;finalizations&gt;</em> section).<br />
</p>
<h4>Experiment Types</h4>
<p>The above example runs an Retinotopic Polar Angle mapping experiment. </p>
<p>The second object it declares is named <em>RetinoMap_Object_1</em>, with ID number 0, this object is derived from the <em>RetinotopyMapper</em> script class. It’s purpose is to support the calculation and drawing (with the use of OpenGL) for various kind of Retinotopic visual stimuli like the Polar Angle. At the moment there are only 2 classes available in the Experiment Manager plug-in of which you can derive from for the presentation of  stimuli, these are:</p>
<ol>
  <li><strong>Retinotopic mapping</strong> experiments which make use of the <em>RetinotopyMapper</em> class, see the <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#retinotopic-mapping">detailed explanation</a>.</li>
  <li><strong>QML based</strong> experiments which make use of the <em>QML2Viewer</em> class, this is explained later (see the below <a href="#qml-based-experiments">explanations</a>).</li>
</ol>
<h3>Block-design and Retinotopic mapping Experiments</h3>
<p>The Block-design definition inside the (&lt;actions&gt;, &lt;blocks&gt;) sections defines one or more experiment blocks (for example: &lt;block ID=&quot;0&quot;&gt;), each block again has an unique ID. Each block is defined by the elements:</p>
<p><strong>&lt;name&gt;</strong> : With this element you can define the name for the block. At the moment this parameter is not yet used by the EM.<br />
  <strong>&lt;block_number&gt;</strong> : This element defines the block number and thus when the block is active. All numbering inside the EM starts counting at 0. Please note that the position of the block sections and their ID do not define when the block is active.<br />
  <strong>&lt;nr_of_trials&gt;</strong> : This element defines the number of trials for this block. For each trial all defined block settings inside the block element are used. Each trial can be triggered by one or more other object(s) (i.e. this could be a timer like the example experiment but also a special hardware port that can emit a signal). This other object then defines how fast it triggers the EM by connecting its signal to the incrementExternalTrigger() slot of the EM. The EM then processes these incoming triggers (signals) automatically by changing the state of the experiment structure automatically. This experiment structure is defined by the current block, trial and internal trigger number. <br />
  <strong>&lt;nr_of_internal_triggers&gt;</strong> : This element defines after how many internal triggers the EM should switch to the next trial for the block (or next block if there are no more trials, or end the experiment if there are no more blocks defined).<br />
  <strong>&lt;nr_of_external_triggers&gt;</strong> : This element defines after how many external triggers received by the EM (by invoking the slot incrementExternalTrigger()) the internal trigger counter should be incremented with one. Normally this is element is set to value ‘1’ making the internal and external trigger counter increment synchronously.<br />
  <strong>&lt;object ID=&quot;&lt;ID&gt;&quot;&gt;{&lt;parameters&gt;}</strong> : The parameters section defines all the parameter(s) for the experiment object (with Object ID=&lt;ID&gt;). These parameters can here be defined for each block section. These parameters are then automatically parsed and used by the experiment object in our example case by, the object with ID=1, the <em>RetinotopyMapper</em> object. </p>
<p>We see that each parameter has an unique name and a corresponding value. In the example experiment file there’s a parameter named <em>RetinoPattern</em>. This parameter defines which type of Retinotopic mapping visual pattern is shown on the screen for the current block. The first block (with block_number 0) shows an fixation cross (<em>fixation</em>) on the screen, the second block shown a polar angle (<em>PolarAngle</em>) Retinotopic pattern on the screen. All parameter names are case insensitive and hold (buffer) their last set value during the whole experiment and therefore you do not need to define the values for them if they don’t change.</p>
<h3>Running an Experiment File from script</h3>
<p>Another way to run Experiment files is to construct an EM in the  script context and then control that EM object in the script to execute the  Experiment. The EM plug-in defines a script class which we can then use to construct a new EM script object. Running experiments like this gives us much more flexibility and control over the EM object and thus the experiment. The <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html">EM script class</a> defines several public signals and slots we can access and use inside the script context for more control and functionality:</p>
<ul>
  <li>Open the file <em>RetinotopicMapping.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\RetinotopicMapping\</em>.</li>
  <li>Quickly examine the QtScript code.</li>
</ul>
<p>The script first constructs a EM object (<em> = new ExperimentManager();</em>) needed for running the Experiment. It then makes use of a StimulGL script function (<em>getActiveDocumentFileLocation()</em>) to retrieve the directory path of the script file, the variable is later used to create a directory pat to the Experiment File (*.exml) which contains the configuration of the Experiment for the EM. It then  defines some local script functions that are  connected to some EM signals for further integration within the script context inside the function (<em>ConnectDisconnectScriptFunctions()</em>). <br />
  In the  end of the script we set the Experiment File directory path by using the EM Slot <em>setExperimentFileName()</em> (see code at the end of the document) and then run the Experiment with <em>runExperiment()</em>. The <em>CleanupScript()</em> function is invoked when the EM signals that it has been stopped in the function <em>ExperimentStateChanged()</em> and this will then nicely follow the guidelines for garbage collection and exit/release the script.</p>
<h4>Experiment states</h4>
<p>The EM can pass different states after it has been constructed because it works like a sort of <a href="http://en.wikipedia.org/wiki/State_machine" target="_blank">state machine</a> for running experiments. A signal named <em>ExperimentStateHasChanged()</em> is emitted each time after the EM state changes. You can connect this signal to a script function, as the example does. By doing this you have more control and information about the EM. The example makes use of this option to automatically call the <em>CleanupScript()</em> function after the state changes to <em>ExperimentManager_Stopped</em>. The documentation for the different Experiment Manager states is available <a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_experiment_manager.html" target="new">here</a>.</p>
<p>The experiment can be stopped (or aborted) by several reasons, the user can normally abort it by pressing <em>CTRL+’a’</em> when it has been started or when something goes wrong or when the Experiment has been completely executed.</p>
<h3>QML based Experiments</h3>
<p>An huge advantage of using a Retinotopic mapping experiment object is it’s visual presentation speed, accuracy and flexible parameter configurability. Aside Retinotopic experiments there’s also a need for a more rich featured experiment type that allows the presentation various content like text, movies, sounds, pictures and easy input from keyboard and mouse. For this purpose the EM also supports the usage of <a href="http://qt-project.org/doc/qt-5.0/qtdoc/gettingstartedqml.html" target="_blank">QML-based</a> experiments (*.qml) files, that contains QtQuick2 code, by implementing the <strong><em>QML2Viewer</em></strong> experiment object (instead of the <em><strong>RetinotopyMapper</strong></em> object). In the &lt;declarations&gt; section of the Experiment File we can then also declare an object of this object class and use it's features in the experiment. We can use this <strong><em>QML2Viewer</em></strong> experiment object directly by executing one of it's input (*.qml) files (a QtQuick2 content file) by StimulGL or by the Experiment Managers UI, let's try this:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the static StimulGL plug-in named <em>ExperimentManagerPlugin</em> exists  by opening the menu <em>Help -&gt; About StimulGL</em>.</li>
  <li>Open the <em>Experiment Manager plug-ins User Interface</em> by opening the<em> Plugins -&gt; Extensions Plugins -&gt; Experiment Manager</em> Plugin menu option.</li>
  <li>Click the <em>Run QtQuick2 File</em> button and browse to open and execute the<em> Helloworld.qml</em> QtQuick2 file found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\</em> directory<em>, </em>please remember that you can always abort the experiment with the <em>CTRL + ‘a’</em> key combination.</li>
  <li>Close the EM plug-in User Interface.</li>
</ul>
<p>The EM first tried to parse the files QtQuick2 code and execute this QML-based  file. As a result we saw a screen presented with a yellow background,  a  &quot;Hello world&quot; text and two filled rectangles (red and blue). Again we can also execute this  file  directly from within StimulGL because the EM also installed a custom execution handler for this type of file (*.qml), let's try this:</p>
<ul>
  <li>Open the<em> </em> <em>Helloworld.qml</em> file again but now directly from within StimulGL.</li>
</ul>
<p>We can now see the content of the file. It’s plain  text  containing some declarations (the QtQuick2 code).</p>
<ul>
  <li>Examine the file content, and try globally understand how the documents content declaratively defines everything we just saw when we executed the document. Further explanation of the QtQuick2 syntax and how you can make use of it  is not fully explained in this getting started guide. In the <em>StimulGL\examples\Tutorials\</em> you can find tutorials about some  features and about how you can make use of these QtQuick2 files for creating your own experiments.  If you are further interested in reading/learning  this a good practice is to start  reading the online <a href="http://qt-project.org/doc/qt-5.0/qtquick/qtquick-quickstart-basics.html" target="_blank">Qt documentation</a> about this.</li>
</ul>
<h4>Editing QML-based files with Qt Creator</h4>
<p>Qt offers an extensive Integrated Development Environment (IDE) package for designing Qt based applications; the <a href="http://qt-project.org/doc/qtcreator-2.8/" target="_blank">Qt Creator IDE</a>. This package also contains the <a href="http://qt-project.org/doc/qtcreator-2.8/creator-using-qt-quick-designer.html" target="_blank">Qt Quick designer</a>. This is a textual and easy WYSIWYG (What-You-See-Is-What-You-Get) visual editor for QML files with QtQuick2 content. It allows you to rapidly design and build Qt Quick (*.qml files) components from scratch. It is completely integrated into Qt Creator and works seamlessly with the QML code editor. Both modes (design and edit) can be used according to requirements. You can download the IDE <a href="http://qt-project.org/downloads#qt-creator" target="_blank">here</a>. See a <a href="http://www.youtube.com/watch?v=k5gMAMSz77Q" target="_blank">YouTube movie</a> demonstrating some of the basic Qt Quick editing features using Qt Creator. The installation of QtCreator is pretty easy, let's try this:</p>
<ul>
  <li>Browse to the QtCreator <a href="http://qt-project.org/downloads#qt-creator"  target="_blank">download page</a> and download the latest installer for your platform.</li>
  <li>Execute the installer and install QtCreator using the default installation options.</li>
  <li>Launch Qt Creator.</li>
  <li>Open the <em>Helloworld.qml</em> file from<em> the directory StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\ </em>from QtCreator. Go to the <em>Design mode</em> (left toolbar, third button) and notice the error that pop-ups. This is because  StimulGL by default can't edit QtQuick2 content in design mode, for this it needs an additional extension. We can add this extension, first we close QtCreator, then we download needed extension file (<em>qml2puppet.exe</em>) from <a href="http://docs.google.com/file/d/0B90qhWJ3-8NZWEVhdmJqdkZBWkE/edit?usp=sharing">here</a>. Once downloaded make sure to copy the file to the QtCreator's <em>bin</em> directory (<em>C:\Qt\qtcreator-&lt;version&gt;\bin</em>).</li>
  <li>Start QtCreator again and retry to view the <em>Helloworld.qml</em> file within the <em>Design mode</em>, please be patient because this can take some time.</li>
  <li>Although we can now open the <em>Design mode</em> for QtQuick2 files we see that it's pretty slow and it still complains about an <em>invalid property name</em>, we'll fix these issues by creating and editing a QtQuick2 project file. </li>
  <li> Close QtCreator again.</li>
</ul>
<p>We'll now see how we can  use a custom StimulGL script to create automatically a QtQuick2 project file that can be loaded/edited by QtCreator. Furthermore we'll see how we then can access  StimulGL from QtCreator for running the QtQuick2 content.</p>
<ul><li>Start StimulGL.</li>
  <li>Open the script file <em>CreateQtCreatorProject.qs</em> from the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\</em>. This script can create a QtQuick2 project file that can be opened in QtCreator.</li>
  <li>Execute the script. </li>
  <li>First the script opens a dialog where you can browse and select a QtQuick2 (*.qml) file that is going to be the main source file for the new QtQuick2 project. Browse to the <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\</em> directory and select the <em>Helloworld.qml</em> file.</li>
  <li>Hereafter the script pop-ups another dialog where you can define where the QtQuick2 project file (*.qmlproject) should be saved. Browse to the same directory as the above input QtQuick file and enter <em>HelloWorld_project.qmlproject</em> for the file name.</li>
  <li>The script finishes and in the directory you can see that the above QtQuick2 project file has been automatically created for you, open this file in StimulGL and examine its contents. We see that this file defines a file path to an QtQuick2 input file and some directory paths that can contain 	content (Qml, 
JavaScript and Image Files) for the QtQuick2 project. </li>
  <li>Not only  the internal QtScript engine can be extended by using plug-ins like we saw before but also the internal QML/QtQuick2 engine of StimulGL. By default there are already some plug-ins installed with StimulGL and it's important to include this StimulGL QML plug-in directory to the QtQuick2 project to make sure that new types and functionality from the plug-ins are then known by QtCreator when opening a QtQuick2 project file. For defining this QML plug-in path we can make use of the    parameter <em>importPaths</em> inside the QtQuick project file, we see that the script  already automatically defined this for us. </li>
  <li>Close the <em>HelloWorld_project.qmlproject</em> file in StimulGL and open it again but now by using QtCreator. You might also want to set QtCreator to automatically open future QtQuick2 projects (<em>*.qmlproject</em>) files  for you, by setting it's file extension type association (see an <a href="http://support.microsoft.com/kb/307859/en-us" target="_blank">explanation</a> for doing this in Windows).</li>
  <li>Notice how the QtQuick2 project automatically includes additional files from the same directory. You can see this in the <em>Projects</em> pane (Top Left) file tree, use this pane to open (double click) the <em>Helloworld.qml</em> file.</li>
  <li>If we now switch to the <em>Design mode</em> we'll see the file presented in a WYSIWYG (What-You-See-Is-What-You-Get) visual editor and by using our mouse we can simply select and edit (see also the property pane on the right) the QtQuick2 file.</li>
  <li>The (visual) editing features of QtCreator are really convenient if we need to edit the QtQuick2 contents. We can then already preview the QtQuick2 content visually but if we want to test how the QtQuick file really behaves we should executes the file. Let's try this in QtCreator by pressing the <em>CTRL+'r'</em> (Run) key combination or the <em>Run</em> button (Bottom Left pane). We can see that QtCreator executes the QtQuick content inside a window that pop-ups. We can even set breakpoints in the editor and use this for debugging the QtQuick2 content.</li>
  </ul>
<p>We can also make use of StimulGL to execute QtQuick content from within QtCreator, before we can do this we should register StimulGL in QtCreator as an external tool that can execute QtQuick2 files, let's try this:</p>
<ul>
  <li>Open the menu <em>Tools --&gt; External --&gt; Configure...</em> from within QtCreator.</li>
  <li>Select <em>Qt Quick</em> from the tree view pane, here you can already see the tools that are registered for editing/executing QtQuick files.</li>
  <li>Click the button <em>Add-&gt;Add Tool, </em>double click on the newly created item the tree view pane and rename the item to something like <strong>StimulGL (execute QtQuick2)</strong>.</li>
  <li>Complete the configuration by entering the following settings:
    <ul>
      <li><strong>Description</strong>: a description like:<em><strong> Executes the current active QtQuick2 document with StimulGL</strong></em><strong></strong></li>
      <li><strong>Executable</strong>: the file path to the StimulGL executable (without the extension!), like <em><strong>C:\Program Files (x86)\StimulGL\StimulGL</strong></em></li>
      <li><strong>Arguments</strong>: the arguments to pass to the StimulGL executable, we'll pass the QML document path using the StimulGL -f (file(s)) command line switch (as explained in this guide) and the -e (execute) command line switch to make sure that it executes directly, like <em><strong>-f %{CurrentDocument:FilePath} -e</strong></em></li>
      <li><strong>Working directory</strong>:the working directory, we'll use the documents directory for this, like <em><strong>%{CurrentDocument:Path}</strong></em></li>
      <li><strong>Output</strong>: Select the <em><strong>Show in Pane</strong></em><strong></strong> option</li>
      <li><strong>Error output</strong>: Select the <em><strong>Show in Pane</strong></em><strong></strong> option</li>
      <li><strong>Modifies current document</strong>: Leave this setting <strong><em>unchecked</em></strong>.</li>
      <li><strong>Input</strong>: Leave this field empty</li>
      </ul>
  </li>
  <li>Press <em>Apply</em> and <em>OK</em> to close the settings dialog.</li>
  <li>Test the newly registered external tool by executing the menu <em>Tools --&gt; External --&gt; Qt Quick --&gt; StimulGL (execute QtQuick2)</em> command. The current active QtQuick2 document should now open in StimulGL and automatically execute.</li>
  <li>Notice that StimulGL always executes the QtQuick2 content in a frameless full screen window.<br />
  </li>
  </ul>
<h4>Access QML based files from an EXML based Experiment File</h4>
<p>We can also make use of the  <em>QML </em> <em>(QtQuick2 content) based </em>files  from within <em>EXML based</em> Experiment files. This collaboration creates a huge advantage because we can then combine the advantages (speed, plug-in  flexibility and block designs features) from the <em>Experiment files (*.exml files)</em> together with the advantages (rich, fast and easy to setup content) of <em>QtQuick2 (*.qml files)</em> within the <em>Experiment Manager</em>. Let’s take a look at an example of how we can achieve this:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the<em> BlockDesign1.exml</em> Experiment file found in the  <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\ </em>directory.</li>
  <li>Examine the experiment file content, notice how a object (named <em>QML2Viewer_Object_1</em>) is derived from the <em>QML2Viewer</em> class is declared (line 20) and used in the experiment for the (visual and auditory) presentation. There are 3 blocks  defined that each define a <em>QmlMainFilePath</em> parameter for the <em>QML2Viewer_Object_1</em> object. This parameter sets the input QtQuick2 (*.qml) file for the <em>QML2Viewer_Object_1</em> object. We can view these different QtQuick2 files with StimulGL or QtCreator as explained before.</li>
  <li>To see what these files (<em>Acai.qml</em>, <em>Banana.qml</em> and <em>Fixation.qml</em>) describe let's open them separately in StimulGL and execute them directly (from  StimulGL).</li>
  <li>Inside the Experiment file we also see an <em>Timer_Object_1</em> object (derived from the <em>TriggerTimer</em> class) declared (line 28). This timer is connected (line 37) to the <em>incrementExternalTrigger()</em> slot of the <em>QML2Viewer_Object_1</em> object which then leads to an change in the experiment structure (as mentioned before). We can also see how the experiment structure is defined, there are 3 blocks defined that take in total 2 external triggers. Because the <em>Timer_Object_1</em> object fires each second (line 54) the total experiment takes 6 seconds, and one block 2 seconds.</li>
  <li>Execute the experiment file and press the <em>'Alt'</em> key to start the experiment and notice what happens.</li>
  <li>Press the<em> ‘Alt’</em> key to start the experiment file and observe what happens, wait until the experiment automatically finishes.</li>
  <li>We just saw an experiment that combined the advantages of the  <em>QML </em> <em>(QtQuick2 content) based </em>files  and the  <em>EXML based</em> Experiment files. By doing it like this we combined the (visual and auditory) presentation defined inside the  QtQuick2 content together with the Experiment Structure inside the Experiment file.</li>
  </ul>
<p>The above example shows how we can setup an experiment by combining the Experiment Structure with the Experiment Presentation. This works fine but we might want to improve the experiment to:</p>
<ol>
  <li> Make sure that all the (visual and auditory) experiment presentation, as defined in the various QML files, is defined in only one single QML file (instead of three files). This has some important  advantages, like that if we need to change the experiment presentation we only need to edit  one file. Furthermore  because (like in this example) some QML  files are often almost identical  (compare the <em>Acai.qml </em>and <em>Banana.qml file</em>), using one file that reuses functionality for different presentation states makes it less error-prone and more modular in use, often this also speeds up the execution of a QML file. A disadvantage might be that the code looks a bit more complex to understand...</li>
  <li>Add an visual component to the Presentation (QML file) that show us the current state of the experiment structure while the experiment is running, we'll use this component for  feedback and testing purpose.</li>
  <li>Start the Experiment file from  a script that creates a <em>ExperimentManager</em> object  and uses this object to dynamically load and execute the Experiment file (*.exml). Using this  script  then gives us the advantage of having more control over the experiment and all of it's objects, which is  convenient because this gives us more direct access, flexibility and control over the experiment. In our example the script will add support for:  </li>
  </ol>
<ul>
  <ul>
    <li>controlling the presentation (QML file) by invoking a function defined inside the QML file that can change the experiment presentation stimuli.</li>
    <li>the randomization  of an array defined in the script that is used to determine which stimuli presentation should be activated (Acai/Banana or fixation) in a BlockTrial. </li>
    
    <li>controlling the presentation (QML file) by invoking a function defined inside the QML file that can change the visual experiment structure presentation.</li>
    <li>making use of the Output Log Pane capabilities of StimulGL from the script to extract various experiment information while it's running.</li>
  </ul>
  </ul>
<p>The above improvements result in a experiment that consists out of 4 files, found in the  <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\QtQuick2\ </em>directory, these are:</p>
<ol>
  <li><em>FruitsExperiment.qs</em>, the main script file that can start and takes control over the Experiment execution.</li>
  <li><em>BlockDesign2.exml</em>,  the experiment file that defines the  Experiment structure and the Experiment configuration.</li>
  <li><em>Fruits.qml</em>, the main QML  file that defines the Experiment presentation (visual and auditory), it also implements a interface by describing one or more function(s) that can be executes from a script file for the control of the presentation state.</li>
  <li><em>ShowExperimentStructure.qml</em>, another QML file that defines a component which is embedded/used and used in <em>Fruits.qml</em> that can be used to visually present the current Experiment Structure. This file also implements a interface by describing a function that can be used from the main script to control the Experiment structure presentation to the screen.</li>
</ol>
<p>All four files can be executed separately directly by StimulGL, but all the important  experiment control takes place in the script and that's why we should now use the script file to start and test the experiment. The script (<em>FruitsExperiment.qs</em>)  dynamically creates a <em>ExperimentManager</em> object that loads and executes the Experiment file (<em>BlockDesign2.exml</em>) which declares a <em>QML2Viewer</em> object for the execution of the QML file (<em>Fruits.qml</em>) that embeds another QML file (<em>ShowExperimentStructure.qml</em>) for the presentation of the Experiment Structure. Whenever the Experiment Structure changes this is automatically signalled to the script (signal/slot connections) which is then  responsible for the control over the presentation state made available by the interface described in the QML files. The choose of presentation state is selected from a pre filled and randomized Array that contains the states (Acai or Banana) for the experiment presentation. The Experiment Structure defined in the Experiment file (<em>BlockDesign2.exml</em>) now defines only two blocks and uses only one QML file. The first block is the fixation block and lasts for 5 external triggers (again 5 seconds for this case). The second block lasts for 10 trials of 2 external triggers, thus 10 trials of 2 seconds. Each trial of the second block is then automatically controlled by the script that uses an randomized array that defines whether the experiment should present the Acai or Banana state. The script also takes control over the visual presentation of the Experiment Structure.</p>
<h2>Multiple program instances and Network Communication (advanced)</h2>
<p>StimulGL allows by default only one instance of the program running simultaneously. If you try to start another instance it will  check first automatically whether a StimulGL instance is already running. You can change the allowance of the simultaneous instances:</p>
<ul>
  <li> In the <em>Tools--&gt;Options</em> menu, there's a 'General' tab with the <em>Allow multiple instances running simultaneously</em> checkbox. If you uncheck (default) this option and try to start another instance by executing another StimulGL executable (StimulGL.exe) you'll notice that the first (already opened instance) is re-activated again (becomes the active window) and no other instance is opened. Let's check this by making sure that this checkbox is unchecked.</li>
  <li>Try to Start another StimulGL instance by executing a StimulGL.exe file. When the new StimulGL instances detects another instance running it informs that instance by broadcasting some messages (actually these messages are scripts) to this instance. These messages are send over the internal TCP/IP network. Whenever new messages (scripts) are received these are automatically shown in the log output pane, therefore you should now see in the log output pane from the first instance running something like:</li>
</ul>
<p class="codeframe"><em>-&gt; SocketData Received [Log(&quot;New StimulGL Instance Initializing...&quot;);]<br />
  New StimulGL Instance Initializing...<br />
  -&gt; SocketData Successfully executed by the Script Engine.<br />
  -&gt; SocketData Received [StimulGL.activateMainWindow();]<br />
  -&gt; SocketData Successfully executed by the Script Engine.</em></p>
<p>The receiving instance receives 2 scripts (see the above two script line(s)  between the brackets ([])) from an <strong>internal Network Server</strong> over an internal TCP/IP socket and automatically executes them as you can see. This internal Network Server is started by StimulGL after startup and can be used for external access. Whatever it received is interpreted a StimulGL script code and automatically executed. This network server runs  internally which means that  it can only be used from within the same computer.</p>
<p>There's also an <strong>External Network Server </strong>available in StimulGL  to which other instances of StimulGL (or other programs that implement this) can connect  to. They can then   control StimulGL by this External network server over the internal and external TCP/IP network. Received messages are again automatically executed by StimulGL.   Clients can connect to this StimulGL External Network Server directly from the same computer or over a TCP/IP network such as the internet as long as the network permits/forwards this TCP/IP communication. Let's try this external network server:</p>
<ul>
  <li>Start one StimulGL instance and make sure to check the option <em>Allow multiple instances running simultaneously</em>.</li>
  <li>Open the Options Dialog by the menu Tools--&gt;Options.</li>
  <li>Open the 'Network' tab and check the <em>Enable the External Network Server at startup</em> checkbox. Enter '127.0.0.1' in the Server IP-Address and '200' in the Server Port setting.</li>
  <li>Close and re-start StimulGL again (this is needed for starting the External Network Server if it was not yet enabled in the settings), we'll be calling this new instance <em>instance A</em>. You may see a Windows warning which asks you wether you want to allow this network communication, you should allow this.</li>
  <li>Notice the line <em>&quot;Network Server started @ 127.0.0.1:200&quot;</em> in the log output pane, we now know that the server is successfully started.</li>
  <li>Start another instance of StimulGL, we'll be calling this instance <em>instance B</em>.</li>
  <li>Notice the line <em>&quot;Configured Network Server disabled.&quot;</em> in the log output pane, because only one Network Server can be active at the same time for a certain IP-Address and port combination.</li>
  <li>Open the file <em>TCPNetworkClient.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\AdvancedScripting\</em> with <em>instance B</em> of StimulGL.</li>
  <li>Examine and then execute the QtScript code.</li>
  <li>Press  some keys and notice that their corresponding key-code is send (in a wrapped script function that logs the key-code value) from StimulGL <em>instance A</em> to <em>instance B</em> over the network card.</li>
  <li>Press the 'Escape' key to finalize the script, notice how the Server detects that the client disconnects.</li>
</ul>
<h2>How to proceed...</h2>
<p>Due to the huge capabilities of StimulGL this getting started guide might be difficult to fully understand immediately, this is not a  problem. It's important to gain a general idea of how StimulGL works and  what it's main capabilities are. If you then want to give it a try you could then start by copying a example from this getting started guide or from one of the <a href="..\index.html">tutorials</a> found in the <em>StimulGL\examples\Tutorials</em> directory. Off course you can also always contact us at sven dot gijsen at maastrichtuniversity dot nl for feedback and questions.</p>
<p>&nbsp;</p>
</div>


</body>
</html>
