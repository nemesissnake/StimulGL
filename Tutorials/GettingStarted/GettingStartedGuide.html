<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../../css/Default.css" rel="stylesheet" type="text/css" />
<link href="../../google-code-prettify/prettify.css" type="text/css" rel="stylesheet" />
<script src="../../js/jquery.min.js" type="text/javascript"></script>
<script src="../../js/jquery.tableofcontents.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../js/StimulGL.js" type="text/javascript" charset="utf-8"></script>
<script src="../../google-code-prettify/prettify.js" type="text/javascript"></script>
<script type="text/javascript" charset="utf-8">
	var StimulGLInfo = new StimulGL_Information();
	var DocTitle = StimulGLInfo.GetDocumentTitle(window.location.pathname);	
	$(document).ready(function()
		{ 
			$("#toc").tableOfContents(
				$("#toc_Area"),        // Scoped to div#toc_Area
				{
					startLevel: 2,    // H2 and up
					depth:      4,    // H2 through H5,
				}
			); 
			prettyPrint();			
		}
	);
	document.write("<title>" + DocTitle + "</title>");	
</script>
</head>
<body>
<script type="text/javascript">StimulGLInfo.GetDocumentHeader(window.location.pathname)</script>
<div id="toc_Area">
<ul id="toc"></ul>
<h2>Introduction</h2>
<p>The purpose of this document is to show you the basic features of StimulGL in a tutorial way. 
The most convenient way of working through this document is starting from the beginning and follow all tutorials 
till the end of the document. You could also only follow a single specific tutorial of your interest but then please bear 
in mind that some tutorials expect you to already gained some knowledge of previous tutorials. This Getting started guide is 
not perfect and continuously under construction, so I would be happy to receive feedback about bugs, typos, comments, 
new ideas, etc at sven.gijsen at maastrichtuniversity dot nl.</p>
<h2>Installation</h2>
<p>Installing StimulGL on your computer is easy, you can download the latest installer file from <a href="http://github.com/svengijsen/StimulGL/downloads" target="_blank">https://github.com/svengijsen/StimulGL/downloads</a>, 
this site also hosts the public StimulGL repository. Before installing you should make sure to logon with administrator rights. There are some virus scanners which trigger a false virus detection due to the automatic installation of various (network) libraries. If you should receive a detection message like this, which doesn’t apply for the mostly used virus scanners, then you could consider turning the realtime protection off for the installation process. StimulGL is available for Windows in a 32-bit(win32) and a 64-bit(x64) architecture. Please make sure to install the correct architecture for your OS. If you’re not sure which one you have then you can execute the following Command Prompt command (a Command prompt can be opened using the: <em>Windows start button --&gt; Run... --&gt; enter the text 'cmd' --&gt; hit the enter key</em>):</p>
<table class="codeframe"><tr><td><pre class="prettyprint">
echo %PROCESSOR_ARCHITECTURE%</pre></td></tr></table>
<br />
<p>If it echoes with <em>‘x86’</em> then you’re on a 32-bit architecture, otherwise on a 64-bit.</p>
<p>StimulGL can be easily installed with the default installation options. Test whether it installs correctly after the installation.</p>
<h3>Installation directory</h3>
<p>The StimulGL installer places all files in a single directory, normally this is a directory like <em>C:\Program Files (x86)\StimulGL</em>. Inside this installation directory you can find the following files and directories:</p>
<h4>Default Files<br />
</h4>
<p><strong>StimulGL.exe</strong> - This is the main StimulGl program executable.<br />
  <strong>StimulGL_NoBindings.bat</strong> - This batch file starts StimulGL with a special option to make sure that no script binding are automatically loaded during startup, 
  see below <a href="#qt-library-script-bindings">Qt Library Script Bindings</a>.<br />
  <strong>logfile.txt</strong> - This logfile saves all StimulGL information, exception, warnings and debugging information, use this file to analyse program execution.<br />
  <strong>uninstall.exe</strong> - Use this file to uninstall StimulGL, you can also use the automatic Windows Uninstall feature or simply delete the whole StimulGL installation directory. You should also perform one of these operations before installing another version of StimulGL.<br />
  <strong>assistant.exe</strong> - This executable is used from within StimulGL to show you the help files (<em>'F1'</em> key).<br />
  <strong>*.dll</strong> - Multiple Dynamic-link library (shared libraries) needed and used (linked) by StimulGL to perform various tasks.<br />
  <strong>LICENSE.txt</strong> - This file contains the license agreement information for StimulGL.</p>
<h4>Default Directories<br />
</h4>
<p><strong>apis</strong> - The files inside this directory are used for the implementation of the textual Application Program Interface information used in call tips and for autocompletion during the StimulGL various file editing.<br />
  <strong>documents</strong> - This directory contains all the necessary files for the StimulGL Help functionality.<br />
  <strong>examples</strong> - This directory contains many various example files, also used by this document, which provide the user with some specific examples to gain a better understanding of the program capabilities.<br />
  <strong>outputs</strong> - This directory is used by the StimulGL plugins for the storage of all kind of output, like log-files, generated files, etc. It's not available/visible after a fresh installation, whenever StimulGL tries to write a file to this directory it's automatically created if didn't existed yet.<br />
  <strong>plugins</strong> - This is the root directory in which StimulGL searches for plugins during startup, if they are compatible then they are automatically included in StimulGL for further usage.<br />
  <strong>plugins/[architecture]/script</strong> - This directory contains the default build Qt script bindings, which make it possible to get access to substantial portions of the Qt API from within Qt Script.<br />
  <strong>qml/plugins/[architecture]/</strong> - This is the root directory in which StimulGL searches for QML-plugins to include during the startup of the QML viewer.<br />
  <strong>xsd</strong> - This directory contains XML Schema (<em>*.xsd</em>) files, which let StimulGL validate experiment (<em>*.exml</em>) files. It is used to express a set of rules to which an experiment must conform in order to be considered 'valid' according to that schema.</p>
<h2>User Interface</h2>
<p>The StimulGL User interface consists out an menu bar, one or more document editing pane(s) and an output log pane. The menu bar contains the following items:</p>
<p><strong>File</strong> - this menu item contains commands for various file operations like opening, saving and printing files.<br />
  <strong>Edit</strong> - this menu contains commands for the editing of files and search and replace functionalities.<br />
  <strong>Window</strong> - this menu contains commands for organizing, selecting and viewing one or more document editing pane(s).<br />
  <strong>Markers</strong> - this menu contains commands for the management of markers that can be used to mark or quickly jump to one or more specific position(s) in a loaded document.<br />
  <strong>Document</strong> - this menu contains commands for controlling the execution of various documents like script (<em>*.qs</em>) files.<br />
  <strong>Tools</strong> - this menu contains an option command that lets you configure the StimulGL settings.<br />
  <strong>Plugins</strong> - this menu contains commands for the loaded plugins. With these commands you can open the plugin's  User Interface. The menu is automatically populated  from the plugins that are detected and loaded during the startup of the program. Plugins are divided in <em>Extension</em> and <em>Device</em> plugins.<br />
  <strong>Help</strong> - this menu contains commands for opening the  StimulGL help and for viewing release information about the current StimulGL and the detected plugin(s).</p>
<h2>Editing and Scripting</h2>
<p>At first glance StimulGL features  various text editing tools that are found in standard text editing applications like notepad. It can open multiple documents  simultaneously, the look and feel for these opened document(s) depends on the document extension. StimulGL  automatically detects certain (pre-registered) file types by extension (see for example <a href="#running-an-experiment-file-directly-from-stimulgl">Running an Experiment File directly from StimulGL</a>) and then configures the internal document editor fot this file type (if the file type is compatible/known to StimulGL). This internal document editor configuration contains features like styling choices, support for syntax styling, code completion and call tips that can support  the editing and thus makes it more  more user-friendly.<br />
  A important  file type for StimulGL is  that of a script (<em>*.qs</em>) file. This file may contain <a href="http://en.wikipedia.org/wiki/QtScript" target="_blank">QtScript</a> code and can be executed by the StimulGL internal Script Engine. This makes StimulGL be more that just a rich multiple document editor, namely also a script interpreter. The supported QtScript scripting language it uses is based on the <a href="http://en.wikipedia.org/wiki/ECMAScript" target="_blank">ECMAScript</a> standard with a few extensions, such as <a href="http://qt-project.org/doc/qt-5.1/qtcore/signalsandslots.html" target="_blank">QObject-style signal and slot connections</a> (explained later in this guide).</p>
<h3>Exercises - Scripting</h3>
<h4>Hello World</h4>
<ul>
  <li>Start StimulGL</li>
  <li>Open the file (<em>File -&gt; Open</em>... or use the <em>Ctrl+’o’</em> key combination) <em>HelloWorld.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>You can see that the plain text is automatically highlighted/styled according to the syntax it contains. Text/code can be commented using the single line comment <em>‘//’</em> or the multi-line <em>‘/*’</em> and <em>‘*/’</em> combination. Three variables are declared (using the <em>var</em> statement) and value is assigned to them, except for the third variable which is calculated out of the other two. The value of this variable is then used in a special function called <em>Log()</em> that can write to the StimulGL output log pane. To clear the output log pane right-click on it and select <em>Clear All Output Item(s)</em>. Some times you might want to copy one or more lines from the output log pane, you can do this by selecting the lines (optionally with holding down the CTRL and/or SHIFT key) you want to copy to the clipboard and then right-click on it and select <em>Copy Selected Text</em>.</p>
<ul>
  <li>Execute the Qtscript code by the internal StimulGL script engine by using the key<em> ‘F5’</em> or through the <em>Document -&gt; Execute</em> command.</li>
</ul>
<p>The Qtscript code of the current selected document pane is then evaluated and executed. If the script is valid then you can see in the output log pane when the script started/stopped evaluation and how many time it took. For each <em>Log()</em> function call there’s also an additional line appended to the log output pane.</p>
<h4>Functions and includes</h4>
<p>Within Qtscript you can define functions and includes that allows you to structure the script in a more modular way and take advantages of the use of re-usable code. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the <em>FunctionsAndIncludes1.qs</em> and the <em>FunctionsAndIncludes2.qs</em> files found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>View/activate the <em>FunctionsAndIncludes1.qs</em> file you can use the Window menu for this purpose or use the<em> Ctrl+TAB</em> key combination to scroll through the opened documents.</li>
</ul>
<p>Notice that the script starts with an Include statement that allows you to embed other script (*.qs) files. In this case a function named <em>testFunction3</em> is defined in the included script file. The <em>string</em> parameter from the <em>Include</em> statement holds the script file to add, this can be a absolute or a relative path, if only a filename is defined than the <em>Include</em> function searches for the filename inside the directory where the current running script file is stored. <br />
  You can see that a function header doesn’t need to specify the amount and type of parameter(s) it accepts, nor the return value (see <em>testFunction3</em>) of a function. <em>testFunction1</em> shows how you can iterate through the parameters it receives, but maybe you want to define this like <em>testFunction2</em> to make a better code overview. <br />
  Before the script ends we should set the defined functions again to null to make sure that the script engine can perform a better garbage collection, this is explained later (see <a href="#dynamic-object-construction-and-garbage-collection">Dynamic Object construction and Garbage Collection</a>).</p>
<ul>
  <li>Execute the Qtscript code by the internal StimulGL script engine by using the key <em>‘F5’</em> or through the<em> Document -&gt; Execute </em>command.</li>
</ul>
<h4>Additional StimulGL Functions</h4>
<p>In a previous exercise we already made use of the additional <em>Log()</em> function to write text to the log output pane which can be very useful for debugging purpose. Aside from this <em>Log()</em> function there are more functions made available to the Script Engine of which you can make use of. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the file <em>AdditionalStimulGLFunctions.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Execute the Qtscript code.</li>
</ul>
<p>When we look at the script code we see that it uses some additional functions prepended with the “<em>StimulGL</em>” namespace because these functions belong to the StimulGL main program. We see some functions that can retrieve absolute directory paths, environment information etc, but also some functions that perform StimulGL functionality like <em>find()</em> and<em> closeSelectedScriptFile()</em>. All available additional StimulGL script functions are described in the  <a href="../../References/Script/StimulGLMainApp/Doxygen/class_main_window.html">StimulGL Main Application Scripting Reference</a>.</p>
<h4>Dynamic Object construction and Garbage Collection</h4>
<p>The internal StimulGL Script engine uses garbage collection to reclaim memory used by the script objects when they are no longer needed. An object's memory can be automatically reclaimed when it is no longer referenced anywhere in the scripting environment context by the script engine garbage collector. For this to work properly you need to make sure that you follow the guidelines before ending the script context:</p>
<ol>
  <li>Disconnect all signal/slot connections, signal slot connections are explained later in chapter (see the <a href="#the-signalslots-mechanism">The Signal/Slots mechanism</a> chapter).</li>
  <li>Set all dynamical constructed object (where you used the new statement) to null.</li>
  <li>Set all defined script functions to null.</li>
  <li>Before ending the script finally call the <em>StimulGL.cleanupScript()</em> function to force a garbage collection.</li>
</ol>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the ObjectConstructionAndGarbageCollection.qs file found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Execute the Qtscript code.</li>
</ul>
<p>If you look at the code you can see that an local (built-in type) <em>String</em> object is constructed using the <em>new</em> keyword. This object is constructed from a primitive <em>String</em> and its member functions can now be used to change the <em>String</em>. Before we end the script context we call a function that makes sure that the above guidelines for a successful garbage collection are followed.</p>
<p>We can test what happens if we don't do follow these guidelines:</p>
<ul>
  <li>Comment (using the '//' comment tag in front of the line) the line <em>replaceFirstCharacter=null;</em></li>
  <li>Execute the Qtscript code.</li>
  <li>Notice that the 'Execute' command in the 'Document' menu (or the corresponding toolbar button) is now disabled. This button is automatically disabled by the internal script engine when the script is running. Because the <em>replaceFirstCharacter</em> funtion is not set to null the script engine doesn't know/detect that it can exit the running script. The 'Execute' commend now remains disabled. </li>
  <li>We can force the script engine to restart/release the current script that is running by using the <em>Document-&gt;Abort</em> command.</li>
</ul>
<h4>Qt Library Script Bindings</h4>
<p>To further extend the script engine functionality StimulGL has a feature that automatically detects and integrates (pre generated) Qt bindings for the Qt Script  environment. With these  bindings you get access to substantial portions of the Qt API from within Qt Script. These script binding are automatically loaded from the shared libraries inside the <em>StimulGL/plugins/[architecture]/script/ directory</em> during startup. 
These shared libraries include script binding for the Qt libraries: 
QtCore, 
QtGui, 
QtNetwork, QtWebkit,
QtXml, 
QtXmlPatterns, 
QtSvg, 
QtSql, 
QtOpenGl and 
QtUiTools, see also the <a href="http://qt-project.org/doc/qt-5.0/qtdoc/modules.html" target="_blank">Qt Project Documentation</a>.
</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the shared library named <em>qtscript_gui.dll</em> exists in directory <em>StimulGL\plugins\[architecture]Win32\script\</em>.</li>
  <li>Open the file <em>QtLibraryScriptBindings.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>This example makes use of the <a href="http://qt-project.org/doc/qt-5.1/qtgui/qcolor.html" target="_blank">QColor</a> and the <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qcolordialog.html" target="_blank">QColorDialog</a> class from the QtGui library which is made available in the scripting environment due to the automatic linkage to the Qt Bindings (<em>qtscript_gui.dll</em>), as explained above. <br />
  The script first constructs a <em>QColor</em> object. The passed parameter in the <em>QColor</em> constructor is used to preset the color. The <em>QColorDialog</em> class (not object!), is used to present to the user a color picking dialog allowing a selection of a custom color that is then copied to the <em>QColor</em> object.<br />
  The script makes use of an static <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qcolordialog.html#getColor" target="_blank">getColor()</a> member function which shows the dialog, and allows the user to specify a color. The static member function is called directly from the class <em>QColorDialog</em>. The dialog then prevents further script execution and gives the control back after the user accepted or rejected the color picking dialog. </p>
<ul>
  <li>Examine and execute the Qtscript code.</li>
</ul>
<p>Notice how the output log pane notes that the script is fully Evaluated after the script engine actually ends (after the <em>ScriptCleanupFunction()</em>). We’ll see in the next chapter that this doesn’t have to be like this.</p>
<h4>The Signal/Slots mechanism</h4>
<p>The StimuGL script engine also has support for <a href="http://qt-project.org/doc/qt-5.1/qtcore/signalsandslots.html" target="_blank">Qt-style signal and slot connections</a> available, which makes the script very flexible. It allows the script to dynamically connect/disconnect various objects to each other by  connecting their signal and slots. It is currently not possible to define a new signal in the script; i.e., all signals must be defined by their underlying C++ classes. Signal/slots can be used inside the script for the creation of an event.</p>
<ul>
  <li>Start StimulGL.</li>
</ul>
<p>Make sure that the shared library named <em>qtscript_gui.dll</em> exists in directory <em>StimulGL\plugins\[architecture]Win32\script\</em>.</p>
<ul>
  <li>Open the file SignalSlotMechanism.qs found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
</ul>
<p>This example is almost the same as the previous example, it only differs in the way the color picking dialog is created and handled. This example makes use of the <em>QColor</em> and the <em>QColorDialog</em> class from the <em>QtGui</em> library which is made available in the scripting environment due to the automatic linkage to the <em>Qt Bindings</em> (<em>qtscript_gui.dll</em>). <br />
  The script starts with constructing two objects, a <em>QColor</em> and a <em>QColorDialog</em> object. In this example the color picking dialog creation is done through the constructed object from the class <em>QColorDialog</em> with the use of an non-static member function. The script receives the control back right after the showing the color picking dialog. We now need to make sure that we 
  detect in the script when the dialog is closed (accepted or rejected) so we can further cleanup the script environment. To make sure that we can do this we’ll connect the <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qdialog.html#finished" target="_blank">finished()</a> signal (derived from <a href="http://qt-project.org/doc/qt-5.1/qtwidgets/qdialog.html" target="_blank">QDialog</a>) from the <em>QColorDialog</em> object and connect it to a script function which can then further finish the script. </p>
<ul>
  <li>Examine and execute the Qtscript code.</li>
</ul>
<p>Notice how the output log pane notes that the script is fully Evaluated before the script engine actually ends (after the <em>ScriptCleanupFunction()</em>). </p>
<h4>StimulGL Plugin Script Bindings</h4>
<p>StimulGL has the ability to automatically integrate plugins that can extend the features of StimulGL and/or add new functionality (see the <a href="../../References/Plugins/PluginReference.html">plugin reference</a>). These plugins may also expose this functionality to the StimulGL Script engine, allowing the user to take advantage of these functionalities in the script engine. Each plugin has the ability to implement its own UI for convenient access and testing. 
StimulGL has totally no knowledge of the plugins implementation and does not define how or what they should do, making it a very flexible solution. Some plugins are build-in or delivered with StimulGL and therefore always available and fully up to date after an installation. Plugins can be grouped in either <em>Device</em> or <em>Extension</em> plugins. Furthermore the plugin can define a class where object can be constructed from inside the script. <u>Important</u>: <strong>The UI dialog plugin object and all of it’s settings have no link with any script object created from this plugin!</strong> Let us first view the plugins implemented UI and its features:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the static StimulGL plugin named <em>KeyBoardPlugin</em> exists by pressing the<em> ‘F2’</em> key or by opening the menu <em>Help -&gt; About</em> StimulGL.</li>
  <li>Open the KeyBoardPlugin User Interface by opening the menu <em>Plugins -&gt; Device Plugins -&gt; KeyBoardDevice Plugin</em>.</li>
  <li>Play around with the plugins dialog features to get an understanding of what the plugin can do (It can detect/capture key presses and/or releases...).</li>
  <li><em>Stop</em> the Capture Thread and <em>Close</em> the plugins dialog.</li>
</ul>
<p>We can also construct objects from the plugin:</p>
<ul>
  <li>Open the file <em>StimulGLPluginScriptBindings.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>.</li>
  <li>Examine and then execute the Qtscript code.</li>
  <li>Repeat pressing a keyboard key (ie. key <em>'4') </em> until the script finishes.</li>
</ul>
<p>The script first creates a new object from a class defined by the plugin. This object is then further used to capture key presses. If you take a look to the log output pane then you’ll see a log entry for each key you just pressed. Each key has a Key Code (a unique number for each key) which is also shown in the entry. After pressing 4 keys the script automatically stops capturing keys and finalizes (by following the above guidelines for garbage collection to allow the script engine to release/exit the script that is running). </p>
<h4>Command-line switches</h4>
<p>StimulGL can be started from the command prompt with special defined switches accompanied with one or more parameter(s). By using these command-line switches it is possible to start StimulGL with one or more pre-defined document(s) and/or to enable/disable certain program features.</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open the file <em>StartStimulGL.bat</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\BasicScripting\</em>. A <a href="http://en.wikipedia.org/wiki/Batch_file"   target="_blank">BAT (*.bat) file</a>is a script file which content  can be directly executed by Windows. </li>
  <li>Examine the batch file content,  the <a href="http://en.wikipedia.org/wiki/List_of_MS-DOS_commands#REM"  target="_blank">REM command</a> is used for commenting the text behind it. There are two commands that are executed, see the file for the explaination about those commands. Also notice that the *.bat extension is not compatible with StimulGL, although you can edit is as plain text. The *.bat extension is not pre-registered inside StimulGL and therefore it's shown in the editor as plain text without colouring, custom styles, fonts, etc...</li>
  <li>Close StimulGL and execute this <em>StartStimulGL.bat</em> file directly from Windows by double clicking it.</li>
  <li>Notice that StimulGL is started and that it automatically opened the file pointed to in the batch file. The command switch '-f' implements this feature, see the below table for all available command switches.</li>
  </ul>
<table width="80%" border="1" align="center">
  <tr>
    <th width="13%" align="center" scope="col">SWITCH</th>
    <th width="54%" scope="col">PARAMETER</th>
    <th width="33%" scope="col">DESCRIPTION</th>
  </tr>
  <tr>
    <td align="center">-f</td>
    <td>Path to document(s) separated with a ';' character</td>
    <td>Allows you to let StimulGL automatically open one or more document(s).</td>
  </tr>
  <tr>
    <td align="center">-v</td>
    <td>Verbose mode</td>
    <td>Enables the verbose mode. In this mode StimulGL writes more detailed and more comprehensive information to the log file. It's advised to only use this option for debugging purpose.</td>
  </tr>
  <tr>
    <td align="center">-o</td>
    <td>Option flags (single number)</td>
    <td>Allows you to define one or more option flag(s) for StimulGL. Each flag is defined by a number and multiple flags can be combined together by summing up all their numbers. See the below table for the available flags with their numbers. If you would for example want StimulGL to start with the plugins and scriptbinding disabled you would use the command 'StimulGL -o 3'.</td>
  </tr>
</table>
<p>&nbsp;</p>
<table width="80%" border="1" align="center">
  <tr>
    <th width="18%" align="center" scope="col">FLAG</th>
    <th width="22%" align="center" scope="col">NUMBER</th>
    <th width="60%" scope="col">DESCRIPTION</th>
  </tr>
  <tr>
    <td align="left">DisableAllScriptBindings</td>
    <td align="center">1</td>
    <td>The Qt Library Script Bindings are not loaded during the startup of StimulGL.</td>
  </tr>
  <tr>
    <td align="left">DisableAllPlugins</td>
    <td align="center">2</td>
    <td>The Plugins are not loaded during the startup of StimulGL.</td>
  </tr>
  <tr>
    <td align="left">DisableSplash</td>
    <td align="center">4</td>
    <td>The splash message is not shown during the startup of StimulGL.</td>
  </tr>
  <tr>
    <td align="left">DisableNetworkServer</td>
    <td align="center">8</td>
    <td>The External Network Server (explained later) is not started during the startup of StimulGL.</td>
  </tr>
  <tr>
    <td align="left">VerboseMode</td>
    <td align="center">16</td>
    <td>Verbose mode is enabled during the startup of StimulGL, see also the above table.</td>
  </tr>
</table>
<p>&nbsp;</p>
<h4>Multiple program instances and Network Communication</h4>
<p>StimulGL allows by default only one instance of the program running simultaneously. If you try to start another instance it will  check first automatically whether a StimulGL instance is already running. You can change the allowance of the simultaneous instances:</p>
<ul>
  <li> In the <em>Tools--&gt;Options</em> menu, there's a 'General' tab with the <em>Allow multiple instances running simultaneously</em> checkbox. If you uncheck (default) this option and try to start another instance by executing another StimulGL executable (StimulGL.exe) you'll notice that the first (already opened instance) is re-activated again (becomes the active window) and no other instance is opened. Let's check this by making sure that this checkbox is unchecked.</li>
  <li>Try to Start another StimulGL instance by executing a StimulGL.exe file. When the new StimulGL instances detects another instance running it informs that instance by broadcasting some messages (actually these messages are scripts) to this instance. These messages are send over the internal TCP/IP network. Whenever new messages (scripts) are received these are automatically shown in the log output pane, therefore you should now see in the log output pane from the first instance running something like:</li>
</ul>
<p class="codeframe"><em>-&gt; SocketData Received [Log(&quot;New StimulGL Instance Initializing...&quot;);]<br />
  New StimulGL Instance Initializing...<br />
  -&gt; SocketData Successfully executed by the Script Engine.<br />
  -&gt; SocketData Received [StimulGL.activateMainWindow();]<br />
  -&gt; SocketData Successfully executed by the Script Engine.</em></p>
<p>The receiving instance receives 2 scripts (see the above two script line(s)  between the brackets ([])) from an  <strong>internal Network Server</strong> over an internal TCP/IP socket and automatically executes them as you can see. This internal Network Server is started by StimulGL after startup and can be used for external acces. Whatever it received is interpreted a StimulGL script code and automatically executed. This network server runs  internally which means that  it can only be used from within the same computer.</p>
<p>There's also an <strong>External Network Server </strong>available in StimulGL  to which other instances of StimulGL (or other programs that implement this) can connect  to. They can then   control StimulGL by this External network server over the internal and external TCP/IP network. Received messages are again automatically executed by StimulGL.   Clients can connect to this StimulGL External Network Server directly from the same computer or over a TCP/IP network such as the internet as long as the network permits/forwards this TCP/IP communication. Let's try this external network server:</p>
<ul>
  <li>Start one StimulGL instance and make sure to check the option <em>Allow multiple instandes running simultaneously</em>.</li>
  <li>Open the Options Dialog by the menu Tools--&gt;Options.</li>
  <li>Open the 'Network' tab and check the <em>Enable the External Network Server at startup</em> checkbox. Enter '127.0.0.1' in the Server IP-Address and '200' in the Server Port setting.</li>
  <li>Close and re-start StimulGL again (this is needed for starting the External Network Server if it was not yet enabled in the settings), we'll be calling this new instance <em>instance A</em>. You may see a Windows warning which asks you wether you want to allow this network communication, do this by selecting .</li>
  <li>Notice the line <em>&quot;Network Server started @ 127.0.0.1:200&quot;</em> in the log output pane, we now know that the server is successfully started.</li>
  <li>Start another instance of StimulGL, we'll be calling this instance <em>instance B</em>.</li>
  <li>Notice the line <em>&quot;Configured Network Server disabled.&quot;</em> in the log output pane, because only one Network Server can be active at the same time for a certain Ip-address and port combination.</li>
  <li>Open the file <em>TCPNetworkClient.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\AdvancedScripting\</em> with <em>instance B</em> of StimulGL.</li>
  <li>Examine and then execute the Qtscript code.</li>
  <li>Press  some keys and notice that their corresponding keycode is send (in a wrapped script function that logs the keycode value) from StimulGL <em>instance A</em> to <em>instance B</em> over the network card.</li>
  <li>Press the 'Escape' key to finalize the script, notice how the Server detects that the client disconnects.</li>
  </ul>
<h4>The StimulGL Registry</h4>
<p>StimulGL makes use of the Windows registry to store its program setting/configuration for the current logged on user. To view this information you can do the following:</p>
<ul>
  <li>Start the Windows Registry Editor by:  <em>Windows start button --&gt; Run... --&gt; enter the text 'regedit' --&gt; hit the enter key.</em> You'll notice that a new Registry Editor starts</li>
  <li>Use the Registry Editor to navigate to the <em>HKEY_CURRENT_USER\Software\MBIC, Maastricht Brain Imaging Center\StimulGL(&lt;<strong>version</strong>&gt;, &lt;<strong>architecture</strong>&gt;)</em> path. Inside this path you can navigate through some sub-folders and see all the registry keys used for the StimulGL configuration settings. The settings only apply for the <strong>current logged on user</strong> and only for the StimulGL <strong>version</strong> and <strong>architecture</strong> stated in the coresponding registry path.</li>
</ul>
<h4>Changing the default User Documents Root Directory</h4>
<p>StimulGL makes use of a so called default <em>User Documents Root directory</em>, this directory is opened by default whenever you use the <em>File--&gt;Open</em> command to browse for a file. You might want to change this to another directory, you can do this trough the <em>Tools--&gt;Option--&gt;Directories</em> menu. If you changed this directory you might also want to copy the already present examples from the original folder to this directory.</p>
<h2>Creating Experiments with the Experiment Manager</h2>
<p>We now know that StimulGL is a rich multiple document editor with an internal script engine that can execute scripts and that it can be extended by the use of the plugin framework. The  main goal during  devellopment  was to create a platform for editing and executing behavioural experiments that can be used for cognitive research. Creating behavioural experiments can be done by using solely the StmulGL script engine but this is off course limited and not very easy. Therefore a StimulGL plugin called the <em>Experiment Manager</em> was created to provide more functionality for managing behavioural experiments, see the <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html">Experiment Manager documentation</a>.This chapter we’ll take a look at it’s features and how it can be used to create/edit and run experiments.</p>
<h3>Running an Experiment File from the Experiment Manager Plugin User Interface</h3>
<p>The Experiment Manager User Interface is available through the <em>Plugins -&gt; Extensions Plugins</em> menu. </p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the static StimulGL plugin named <em>ExperimentManagerPlugin</em> exists by pressing the <em>‘F2’</em> key or by opening the menu <em>Help -&gt; About StimulGL</em>. As you can see it marks this plugin as <em>Static</em> which means that this plugin is build into the StimulGL.exe file and is always available. <em>Dynamic</em> plugins are automatically detected and implemented at the StimulGL startup, they also  are available/build in a separate *.dll file and stored in the StimulGL/plugins/&lt;architecture&gt;/ directory. For a c++ programmer it's not difficult to create a new custom StimulGL plugin to extend the program (if you are interested in this please contact us at sven dot gijsen at maastrichtuniversity dot nl).</li>
  <li>Open the <em>Experiment Manager plugins User Interface</em> by opening the <em>Plugins -&gt; Extensions Plugins -&gt; Experiment Manager Plugin</em> menu option. </li>
  <li>Click the<em> Run Experiment File</em> button and browse to open and execute the <em>PolarAngle.exml</em> Experiment file found in the <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\experiments\</em>.</li>
</ul>
<p>We should now see a default screen that allows us to start the experiment (by pressing the<em> ‘ALT’ key</em>) or abort (by pressing the <em>CTRL + ‘a’ key</em> combination). After we have started the experiment we should see a <em>Polar Angle Retinotopic experiment</em> running. We can always abort an experiment by pressing the <em>CTRL + ‘a’</em> key combination or wait until the experiment is finished.</p>
<ul>
  <li>Abort (<em>CTRL + ‘a’</em>) the experiment or wait until it has finished and close the Experiment Manager User Interface.</li>
  </ul>
<p>The experiment we just executed by the Experiment Manager is completely defined in a Experiment File (*.exml), this is explained later.</p>
<h3>Running an Experiment File directly from StimulGL</h3>
<p>Plugins like the ExperimentManager plugin can pre-register specific file type extensions in StimulGL as mentioned before. These registered file types can then be automatically edited and/or executed by the plugin itself without StimulGL interfering. This can be a custom widget that can edit a specific type of a  file but also an  implementation for the execution of that specific file type like we saw before. <br />
  The Experiment Manager Plugin automatically registers the (<em>*.exml</em>) file type extension in StimulGL and implements a custom execution handler for this type of file. This execution handler is called whenever you use the <em>Document--&gt;Execute</em> command in StimulGL. Due to this it’s possible to directly start an experiment file after opening this document with StimulGL even without using the  plugins User Interface like we saw above. Let's try this:</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Open again the file <em>PolarAngle.exml</em> Experiment file found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\experiments\</em> with StimulGL directly.</li>
  <li>Execute the Experiment file directly by using the key <em>‘F5’</em> or through the <em>Document -&gt; Execute</em> command.</li>
  <li>Press the <em>'TAB'</em> key to start the experiment.</li>
  <li>Abort (<em>CTRL + ‘a’</em>) the experiment or wait until it has finished completely.</li>
  </ul>
<p>We now saw that we can start the same Experiment file direcly from within StimulGL by using the execution handler for this file type implemented by the <em>Experiment Manager</em>.</p>
<h3>The Experiment File (*.exml)</h3>
<p>The <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#exml-file-definition">Experiment File (<em>*.exml</em>)</a> is an sort of <a href="http://en.wikipedia.org/wiki/XML" target="_blank">XML file type</a> that describes an experiment. The Experiment file consist out of different sections that determine the behaviour/configuration of the experiment, these sections are automatically processed by the <em>EM</em>. The below global explaination about these sections may be difficult to understand for an average user (non-programmer), this should not be a problem for the usage, but this explaination together with further examples should make things a little bit more clear. In the future development of StimulGL the Experiment Manager plugin will be extended with a user friendly interface to edit these sections.</p>
<p>If we take a look at the example Experiment file we can see that after a standard header that there are different elements defined starting with a start-tag ( for example: &lt;section&gt;) and ending with a end-tag (for example: &lt;/section&gt;) or empty-element tags (for example: &lt;param1/&gt;). These elements may also include other element, named child-elements. The child-elements from the &lt;EXML&gt; element have a special meaning, these are:</p>
<p><strong>&lt;defines&gt;</strong> : Within this section we  define  global Experiment settings.<br />
  <strong>&lt;declarations&gt;</strong> : This section declares objects that can then be  used in the experiment. These  can be standard Qt objects or objects derived from the plugins classes! These objects are then automatically constructed (and afterwards destructed) and managed by the EM.<br />
  <strong>&lt;connections&gt;</strong> : The above derived objects have less or no functionality on their own within the Experiment. Therefore we use this section  to connect them using the <a href="http://qt-project.org/doc/qt-4.8/signalsandslots.html" target="_blank">Qt-style signal and slot connections</a> to other  objects like the EM itself. The objects are automatically disconnected before the experiment has been stopped.<br />
  <strong>&lt;initializations&gt;</strong> : Often we first need  to  initialize the above derived  objects before we can  actually use them in an running Experiment, this section allows us  to do this.<br />
  <strong>&lt;actions&gt;</strong> : This section contains the actual actions that should be performed when running the Experiment. Inside the <strong>&lt;blocks&gt;</strong> child-element you can  describe an sequentially Block-design experiment with pre-defined <strong>&lt;parameters&gt;</strong> that are used by an derived object during the execution of the experiment.<br />
  <strong>&lt;finalizations&gt;</strong> : This section allows you to perform some operations before the EM finalizes the experiment.</p>
<h4>The Experiment Structure and the Experiment Triggering</h4>
<p>Before the Block-design experiment actually starts the user is presented a screen where the experiment can be started or aborted. After the user has presses the <em>'TAB'</em> key to start the experiment, the EM executes the experiment defined in the (&lt;actions&gt;, &lt;blocks&gt;) sections (or the CTRL+a key combination to abort the Experiment).<br />
  Inside the <em>&lt;blocks&gt;</em> section of the <em>&lt;actions&gt;</em> section you can find the sections that define the Experiment Structure  Block(s)/Trial(s)/Internal  and External Trigger(s). This Experiment Structure is used while running the Experiment to step through the different BlockTrial(s) that can be defined with parameter(s) <em>&lt;parameter&gt;</em> for the corresponding object(s) <em>&lt;object&gt;</em>. The Experiment Structure is optimized for the definition of an Block Experiment design. In a block design, two or more conditions are alternated in blocks and trials, these conditions can be defined  by the different parameters for the objects. Each blocktrial will have a duration of a certain number of ie. fMRI scans and within each block only one condition is presented. By making the conditions differ in only the cognitive process of interest, the fMRI signal that differentiates the conditions should represent this cognitive process of interest.<br />
  We see that there are only 2 Blocks defined in the above  <em>PolarAngle.exml</em> Experiment file. The first Block that is executed is the one with Block number <strong>0</strong> (<em>see &lt;block_number&gt;0&lt;/block_number&gt;</em>) and  named <strong>Fixation_Block</strong> (<em>see &lt;name&gt;Fixation_Block&lt;/name&gt;</em>)  has an internal Block-ID of <strong>0 </strong>(<em>see &lt;block ID=&quot;0&quot;&gt;</em>). This Block  only takes <strong>1</strong> Trial (the number of repetitions of this Block) <strong></strong>(<em>see &lt;nr_of_trials&gt;1&lt;/nr_of_trials&gt;</em>) and one Trial takes <strong>2</strong> Internal Triggers <strong></strong>(<em>see &lt;nr_of_internal_triggers&gt;2&lt;/nr_of_internal_triggers</em>) and one Internal Trigger takes <strong>1</strong> External Trigger (<em>see &lt;nr_of_external_triggers&gt;1&lt;/nr_of_external_triggers</em>). So what does this exactely mean? If the Experiment Structure is externally triggered by an signal that for example fires each time the fMRI scanner scans one volume (ie. Tr = 2 Seconds) than the external trigger counter will increment each 2 seconds because the Experiment Manager will then automatically step through the Experiment Structure defined here. Because one Internal Trigger only takes 1 External Trigger in this Block the Internal Trigger is also incremented each 2 seconds (if <em>nr_of_external_triggers</em> would be set to 3 then each Internal Trigger would take 6 (=3*2 seconds in this example) seconds. After 2 Internal Triggers the Trial counter would be incremented if there were more than one Trials defined but because the is not the case it will then advance to the  next Block with  Block Number 1 (=0+1=1), because the Blocks are sequentially activated by their defined Block Number (starting with 0). We now know that the Block with Block Number 0 (the 'Fixation_Block') only takes in total 2 External Triggers, thus 4 Seconds in our example.<br /> 
  The Block with Block Number <strong>1</strong> would thus take (1 External Trigger * 36 Internal Triggers * 6 Trials * 2 seconds per External Trigger) 432 seconds, each Trial  takes 72 seconds. We also see different Parameters defined in the Block definitions. These parameters are linked to the Object with Object ID <strong>1</strong> (<em>see &lt;object ID=&quot;1&quot;&gt;</em>)<em>, </em>this is the Object with the name <strong>RetinoMap_Object_1</strong> derived from the script class <strong>RetinotopyMapper</strong> (see the ObjectID=1 definition in the <em>&lt;declaration&gt;</em> section). The available Parameters from the <strong>RetinotopyMapper</strong> class are described in a <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#retinotopic-mapping">detailed explanation here</a>. We see that the parameters have an fixed value within each Block. Parameters that aren't defined automatically use their default value and if they are changed inside the Experiment File they hold/buffer that value until the Experiment ends. Whenever the current Experiment Structure switches to a new  BlockTrial (Block or Trial) the defined parameter values are parsed and used in the experiment. By implementing a Experiment like the above we have an declarative way of defining different conditions with parameters in a block design Experiment that is defined by our Experiment Structure. The parameter values are now statically defined (they have fixed values) in the Experiment File, later on we'll see how we can dynamically change them inside our  script environment. When there are no more Block to run the Experiment is automatically finalized (see the <em><strong>&lt;</strong>finalizations<strong>&gt;</strong></em> section) and hereafter stopped. We can also always manually abort the Experiment when its running by pressing the CTRL+a (for <strong>A</strong>bort) key combination. Sometimes we also want to be able to increment the External Trigger (see above) manually for testing purpose, we can do this with   the available key combination CTRL+T (for <strong>T</strong>rigger), for each of this key combination press the External Trigger counter increments one step.</p>
<p>In the above example we imagined that the Experiment would be Triggered externally by a signal that would be synchronized with a fMRI scanner Trigger. But in real this Experiment is triggered automatically by a object derived from a <em>TriggerTimer</em> class each 1000 milli-Seconds, next we'll see how this is done.</p>
<h4>Connecting Experiment Objects</h4>
<p>The declared objects in the <em>&lt;declarations&gt;</em> section of the Experiment file have an unique &lt;object ID=&quot;&quot;&gt; tag that is used in all of the remaining  sections to address to that object. In the experiment file, in the declarations section, we see that an object named <em>Timer_Object_1</em>, with ID number 0, is declared and derived from the <em><a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_trigger_timer.html">TriggerTimer</a></em><a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_trigger_timer.html"> script class</a> (this class is made available by the EM). This TriggerTimer object is then used in the Experiment for the automatic triggering of the experiment by connecting its <em>timeout()</em> signal for triggering the experiment. We can see this in the <em>&lt;connections&gt;</em> section, the TriggerTimer <em>timeout()</em> signal is here connected to a <a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_g_l_widget_wrapper.html">incrementExternalTrigger()</a> slot of the <em>RetinotopyMapper</em> class derived object. We use this <em>TriggerTimer</em> class derived object because it can perform very accurate timing and triggering (by emitting a signal) other objects. <br />
We then also initialize (&lt;initializations&gt;) the <em>TriggerTimer</em> object with the<em> startTimer(1000) </em>function before the Experiment actually starts. This function initializes and starts the <em>TriggerTimer</em>object which then signals/emits the<em> timeout()</em> signal each 1000 milli-seconds. When the Experiment stops or has been aborted the <em>Timer_Object_1</em> is stopped automatically automatically because of the slot <em>stopTimer()</em> is then called (see the <em>&lt;finalizations&gt;</em> section).<br />
</p>
<h4>Experiment Types</h4>
<p>The above example runs an Retinotopic Polar Angle mapping experiment. </p>
<p>The second object it declares is named <em>RetinoMap_Object_1</em>, with ID number 0, this object is derived from the <em>RetinotopyMapper</em> script class. It’s purpose is to support the calculation and drawing (with the use of OpenGL) for various kind of retinotopic visual stimuli like the Polar Angle. At the moment there are only 2 classes available in the Experiment Manager plugin of which you can derive from for the presentation of  stimuli, these are:</p>
<ol>
  <li><strong>Retinotopic mapping</strong> experiments which make use of the <em>RetinotopyMapper</em> class, see the <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html#retinotopic-mapping">detailed explanation</a>.</li>
  <li><strong>QML based</strong> experiments which make use of the <em>QML2Viewer</em> class, see the below <a href="#qml-based-experiments">explanations</a>.</li>
</ol>
<h3>Block-design and Retinotopic mapping Experiments</h3>
<p>The Block-design definition inside the (&lt;actions&gt;, &lt;blocks&gt;) sections defines one or more experiment blocks (for example: &lt;block ID=&quot;0&quot;&gt;), each block again has an unique ID. Each block is defined by the elements:</p>
<p><strong>&lt;name&gt;</strong> : With this element you can define the name for the block. At the moment this parameter is not yet used by the EM.<br />
  <strong>&lt;block_number&gt;</strong> : This element defines the block number and thus when the block is active. All numbering inside the EM starts counting at 0. Please note that the position of the block sections and their ID do not define when the block is active.<br />
  <strong>&lt;nr_of_trials&gt;</strong> : This element defines the number of trials for this block. For each trial all defined block settings inside the block element are used. Each trial can be triggered by one or more other object(s) (i.e. this could be a timer like the example experiment but also a special hardware port that can emit a signal). This other object then defines how fast it triggers the EM by connecting its signal to the incrementExternalTrigger() slot of the EM. The EM then processes these incoming triggers (signals) automatically by changing the state of the experiment structure automatically. This experiment structure is defined by the current block, trial and internal trigger number. <br />
  <strong>&lt;nr_of_internal_triggers&gt;</strong> : This element defines after how many internal triggers the EM should switch to the next trial for the block (or next block if there are no more trials, or end the experiment if there are no more blocks defined).<br />
  <strong>&lt;nr_of_external_triggers&gt;</strong> : This element defines after how many external triggers received by the EM (by invoking the slot incrementExternalTrigger()) the internal trigger counter should be incremented with one. Normally this is element is set to value ‘1’ making the internal and external trigger counter increment synchronously.<br />
  <strong>&lt;object ID=&quot;&lt;ID&gt;&quot;&gt;{&lt;parameters&gt;}</strong> : The parameters section defines all the parameter(s) for the experiment object (with Object ID=&lt;ID&gt;). These parameters can here be defined for each block section. These parameters are then automatically parsed and used by the experiment object in our example case by, the object with ID=1, the <em>RetinotopyMapper</em> object. </p>
<p>We see that each parameter has an unique name and a corresponding value. In the example experiment file there’s a parameter named RetinoPattern. This parameter defines which type of retinotopic mapping visual pattern is shown on the screen for the current block. The first block (with block_number 0) shows an fixation cross (<em>fixation</em>) on the screen, the second block shown a polar angle (<em>PolarAngle</em>) retino pattern on the screen. All parameter names are case insensitive and hold (buffer) their last set value during the whole experiment and therefore you do not need to define the values for them if they don’t change.</p>
<h3>Running an Experiment File from script</h3>
<p>Another way to run Experiment files is to construct an Experiment Manager(in short=EM) in the  script context and then control that instance in the script to execute an Experiment. The EM plugin defines a script class which we can then use to construct a new EM script object. Running experiments like this gives us much more flexibility and control over the EM object and thus the experiment. The <a href="../../References/Plugins/ExperimentManagerPlugin/ExperimentManagerPlugin.html">EM script class</a> defines several public signals and slots we can access and use inside the script context for more control and functionality:</p>
<ul>
  <li>Open the file <em>RetinotopicMapping.qs</em> found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\</em>.</li>
  <li>Quickly examine the Qtscript code.</li>
</ul>
<p>The script first constructs a EM object (<em> = new ExperimentManager();</em>) needed for running the Experiment. It then makes use of a StimuGL script function (<em>getSelectedScriptFileLocation()</em>) to retrieve the directory path of the script file, the variabele is later used to create a directory pat to the Experiment File (*.exml) which contains the configuration of the Experiment for the EM. It then  defines some local script functions that are  connected to some EM signals for further integration within the script context inside the function (<em>ConnectDisconnectScriptFunctions()</em>). <br />
  In the  end of the script we set the Experiment File directory path by using the EM Slot <em>setExperimentFileName()</em> (see code at the end of the document) and then run the Experiment with <em>runExperiment()</em>. The <em>CleanupScript()</em> function is invoked when the EM signals that it has been stopped in the funtion <em>ExperimentStateChanged()</em> and this will then nicely follow the guidelines for garbage collection and exit/release the script.</p>
<h4>Experiment Manager public signal and slots</h4>
<p>We’ve just seen some signals and slots that are made available (<em>public</em>) within the script context, see the <a href="../../References/Script/ExperimentManagerPlugin/Doxygen/class_experiment_manager.html">Experiment Manager script class reference</a> for a detailed description of all available signal/slots.</p>
<p>Next the script code executes the EM slot<em> runExperiment()</em>. The EM then tries to run the Experiment and returns the boolean result. If the Experiment could not be started because something is wrong it returns false and the script then runs the <em>CleanupScript()</em> code and exits.</p>
<h4>Experiment states</h4>
<p>The EM can pass different states after it has been constructed and works like a sort of <a href="http://en.wikipedia.org/wiki/State_machine" target="_blank">state machine</a> for running experiments. A signal named <em>ExperimentStateHasChanged()</em> is emitted each time after the EM state changes. You can connect this signal to a script function, as the example does. By doing this you have more control and information about the EM. The example makes use of this option to automatically call the <em>CleanupScript()</em> function after the state changes to <em>ExperimentManager_Stopped</em>. The Experiment Manager state can be:</p>
<p><strong>ExperimentManager_NoState (=0):</strong><br />
  This state is only internally used by the object while it’s constructed and therefore cannot be used in the script environment.<br />
  <strong>ExperimentManager_Constructed (=1)</strong><br />
  This state is used to determine whenever the object has been constructed and therefore cannot be use in the script environment, it’s also internally used.<br />
  <strong>ExperimentManager_Loaded (=2)</strong><br />
  After the Experiment file (*.exml) is successfully loaded (and validated) the EM state changes to this state.<br />
  <strong>ExperimentManager_Configured (=3)</strong><br />
  After the function <em>runExperiment()</em> is called the EM (validates if not done yet) and configures the experiment, it then changes to this state if the configuration was done.<br />
  <strong>ExperimentManager_Initialized (=4)</strong><br />
  After the Experiment configuration the EM tries to initialized and changes the state to this state if this step was successful.<br />
  <strong>ExperimentManager_IsStarting (=5)</strong><br />
  After the Experiment initialization the EM is ready to actually start the Experiment but first it changes the state to this state.<br />
  <strong>ExperimentManager_Started (=6)</strong><br />
  After the Experiment is successfully started the EM changes to this state.<br />
  <strong>ExperimentManager_IsStopping (=7)</strong><br />
  Before the EM tries to stop the Experiment it first changes to this state.<br />
  <strong>ExperimentManager_Stopped (=8)</strong><br />
  After the EM could finalize and stop the Experiment it changes to this state.</p>
<p>The experiment can be stopped (or aborted) by several reasons, the user can normally abort it by pressing <em>CTRL+’a’</em> when it has been started or when something goes wrong or when the Experiment has been completely executed.</p>
<h3>QML based Experiments</h3>
<p>An huge advantage of using a Retinotopic mapping experiment object is it’s speed, accuracy and fast/flexible parameter configurability. Aside Retinotopic experiments there’s also a need for a more less complex experiment type that allows the presentation of rich content like text, movies, sounds, pictures etc. For this purpose the EM also supports the usage of <a href="http://qt-project.org/doc/qt-5.0/qtdoc/gettingstartedqml.html" target="_blank">QML based experiments</a> (*.qml) files by implementing the <strong><em>QML2Viewer</em></strong> experiment object (instead of the <em><strong>RetinotopyMapper</strong></em> object) in the &lt;declarations&gt; section of the Experiment File.</p>
<ul>
  <li>Start StimulGL.</li>
  <li>Make sure that the static StimulGL plugin named <em>ExperimentManagerPlugin</em> exists by pressing the <em>‘F2’</em> key or by opening the menu <em>Help -&gt; About StimulGL</em>.</li>
  <li>Open the <em>Experiment Manager plugins User Interface</em> by opening the<em> Plugins -&gt; Extensions Plugins -&gt; Experiment Manager</em> Plugin menu option.</li>
  <li>Click the <em>Run QtQuick2 File</em> button and browse to open and execute the <em>Example_1.qml</em> QML based file found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\experiments\</em>.</li>
</ul>
<p>The EM now tries to parse the file and hereafter we can execute the file by pressing again the <em>'ALT'</em> key or abort with the <em>CTRL + ‘a’</em> key combination.</p>
<ul>
  <li>Press the ALT key to execute the qml experiment. </li>
</ul>
<p>We now see a yellow rectangle on the screen with inside a black text and two other smaller rectangles (red and blue), by pressing the <em>CTRL + ‘a’</em> key combination we can abort the experiment again.</p>
<ul>
  <li>Close the EM plugin User Interface.</li>
  <li>Open the <em>Example_1.qml</em> QML based file again but now directly from within StimulGL.</li>
</ul>
<p>We now see the content of the file, and it’s just a document containing declarations.</p>
<ul>
  <li>Examine the file and try to find out for yourself how the document contents work, if you are further interested in reading you should start with the online Qt documentation (<a href="http://qt-project.org/doc/qt-4.8/gettingstartedqml.html" target="_blank">QML based experiments</a> (<em>*.qml</em>)).</li>
</ul>
<h4>Editing QML based files with Qt Creator</h4>
<p>Qt offers an extensive Integrated Development Environment (IDE) package for designing Qt based applications; the <a href="http://qt.digia.com/product/developer-tools/" target="_blank">Qt Creator IDE</a>. This package also contains the <a href="http://doc.qt.digia.com/qtcreator-2.4/creator-using-qt-quick-designer.html" target="_blank">Qt Quick designer</a>. This is a textual and visual editor for QML files which supports WYSIWYG. It allows you to rapidly design and build Qt Quick (*.qml files) components from scratch. It is completely integrated into Qt Creator and works seamlessly with the QML code editor. Both modes (design and edit) can be used according to requirements. You can download the IDE <a href="http://qt-project.org/downloads#qt-creator" target="_blank">here</a>. See a <a href="http://www.youtube.com/watch?v=k5gMAMSz77Q" target="_blank">youtube movie</a> demonstrating some of the basic Qt Quick editing features using Qt Creator.</p>
<h4>Access QML based files from an EXML based Experiment File</h4>
<p>We can also access <em>QML based</em> files directly from <em>EXML based</em> Experiment files. This can be really convenient because we can then combine the advantages (speed, accuracy and flexibility) from the <em>Experiment files (*.exml files)</em> together with the advantages (rich and easy to setup content) of <em>QtQuick (*.qml files)</em> within the <em>Experiment Manager</em>. Let’s take a look at an example:</p>
<ul>
  <li>Open the <em>Experiment Manager plugins User Interface</em> by opening the <em>Plugins -&gt; Extensions Plugins -&gt; Experiment Manager Plugin</em> menu option.</li>
  <li>Click <em>Run Experiment File</em> button and browse to open and execute the<em> Example_2.exml</em> Experiment file found in the directory <em>StimulGL\examples\GettingStartedGuide\ExperimentManager\experiments\</em>.</li>
  <li>Press the<em> ‘Alt’</em> key to start the experiment file and observe what happens, wait until the experiment automatically finishes.</li>
</ul>
<h4>Todo, future requests for this document</h4>
<ul>
  <li>Using StimulGL help</li>
  <li>The StimulGL Registry</li>
  <li>ExperimentManager signal and slots detailed overview</li>
  <li>The 'EM' script object</li>
  <li>More examples, especially with the use of QML</li>
  <li>Parameters, inline{} statement, direct usage of object declared in EXML</li>
  <li>Experiment Structure Script Object.</li>
  <li>Custom retinotopic painting</li>
  </ul>
<p>&nbsp;</p>
</div>


</body>
</html>
